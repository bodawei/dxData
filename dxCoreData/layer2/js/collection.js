/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/*global dx, $, _, Backbone */

'use strict';

dx.namespace('dx.core.data');

(function() {
/*
 * This takes a set of schemas (modified by _prepareSchemas), and creates a set of Backbone Collection constructor
 * functions (and, by implication, functionality upon the collections generated by those functions). These will be
 * used by the 'level3' API's to provide final collections to consumers of the data layer.
 *
 * See the comment for level2-models for a list of the specialized terminology used here (e.g. DSB).
 *
 * CONSTRUCTOR FUNCTIONS
 * The collections created by these constructor functions contain groups of DSB Models that all share a common parent
 * type.  These collections can only have their contents changed by way of $$list() operations and the notification
 * system. Unlike DSB models, there are no 'Client' collections.  To have a fully-alterable collection of models,
 * use an ordinary Backbone Collection.
 *
 * EVENTS
 * ready : readyHandler(collection)
 * If you want to know if a collection is ready to be used (has retrieved at least one set of results via $$list()),
 * use the 'ready' event, which is unique to DSB collections.
 * Ready indicates that the collection has retrieved an initial set of models.  Unlike ordinary events, if a ready
 * handler is assigned to a collection that is already ready, that handler (and no others) will be triggered
 * immediately. Ready handlers receive as their first (and only) argument the
 *
 * dirty : dirtyHandler(collection)
 * Indicates that the collection may be out of sync with the server and should be re-$$list()'ed
 *
 * POPULATION
 * Server collections are populated in two ways:
 *   1) A call to $$list() will fill the collection with the current set of models from the server
 *   2) The notification system, if enabled, may cause models to be added and removed from the collection at any time.
 * The operation of $$list() is straightforward.  Notifications are a little less clear.  As the notification system
 * learns of object changes, it will inform the caching system about the changes.  That, in turn will cause the
 * caching system to try to update any collections, adding and removing those models to collections as needed.
 * The decision of whether a model should be added will depend on the query parameters that currently govern the
 * collection (the ones last passed to $$list(), if any).  In some cases, a collection may have a paged set of results,
 * and at that point it can be difficult to determine whether the model should be added to the collection.
 * The filter system (level2-filter) provides per-type filters. It is their responsibility to determine how the model
 * should be dealt with. If it can't determine (as in the case with paging), the collection will trigger a 'dirty'
 * event, which the client of the collection can use to decide how to handle this case. If setAutoPageRefresh(true) has
 * been called on the collection, then in these circumstances, in addition to firing the 'dirty' event, the collection
 * will automatically re-call $$list() with the original query parameters. In this case, the original success and error
 * handlers will be called again after the list operation returns.
 *
 * OPERATIONS
 * The collections created by these constructor functions have these similarities and differences compared to the
 * standard Backbone collections.
 *
 * Standard Backbone properties (none of these should be changed)
 *     models     : -- : The set of models in the collection. Don't access directly. Use at() instead.
 *     length     :    : Standard behavior.
 *
 * Standard Backbone functions
 *     model      : -- : Must not use. Collections can not create their own models.
 *     toJSON     :    : Standard behavior.
 *     Underscore :    : Standard behavior. These are the 'underscore' functions can all be applied to collections.
 *     add        : -- : Do not use. Use $$list() instead.
 *     remove     : -- : Do not use. Use $$list() instead.
 *     reset      : -- : Do not use. Use $$list() instead.
 *     set        : -- : Do not use. Use $$list() instead.
 *     get        :    : Standard behavior.
 *     at         :    : Standard behavior.
 *     push       : -- : Do not use. Use $$list() instead.
 *     pop        : -- : Do not use. Use $$list() instead.
 *     unshift    : -- : Do not use. Use $$list() instead.
 *     shift      : -- : Do not use. Use $$list() instead.
 *     slice      :    : Standard behavior.
 *     comparator :    : Standard behavior.
 *     sort       :    : Standard behavior.
 *     pluck      :    : Standard behavior.
 *     where      :    : Standard behavior.
 *     findWhere  :    : Standard behavior.
 *     url        : -- : Internal use. Don't use.
 *     parse      : -- : Internal use. Don't use. Handles return values from the Delphix Engine
 *     clone      :    : Standard behavior. However, the returned collection is an ordinary Backbone Collection.
 *     fetch      : -- : Do not use. Use $$list() instead.
 *     create     : -- : Do not use. DSB Models have more complex creation semantics. use rootOps..$$create().
 *
 * DSB Collection functions
 *     $$list             :    : Populates the collection with a selection of models from the server.
 *     getQueryParameters :    : Returns the query parameters used to populate this collection via $$list
 *     clear              :    : Removes all models from the collection, empties any query parameters, and blocks any
 *                               models from being auto-added until another $$list is issued
 *
 * Private to dxCore Data
 *     context._collectionConstructors : The set of collection constructor functions
 *     context._newServerCollection    : Creates a new Server Collection
 *
 * Parameters:
 *     schemas: The set of schemas this should generate constructors from.
 *     context: The object to put the resulting constructors (_collectionConstructors) on. If not specified, puts them
 *              on 'this'.
 */
dx.core.data._generateCollectionConstructors = function(schemas, context) {
    var LISTINGMODE_IDLE = 0;
    var LISTINGMODE_LISTING = 1;

    /*
     * ========================================
     * Collection functions
     * ========================================
     */

    /*
     * Backbone defines this as: Bind a callback function to an object. The callback will be invoked whenever the event
     * is fired.
     *
     * For DSB collections, we provide standard behavior for this, but do some special processing if someone is
     * listening for the 'ready' event. In that case, if we have done a $$list() successfully, then we trigger the
     * ready event immediately.
     */
    function dxOn(name, callback, context) {
        Backbone.Events.on.call(this, name, callback, context);
        if (name === 'ready' && this._dxIsReady) {
            this.trigger('ready', this);
        } else if (name === 'error' && this._dxIsErrored) {
            this.trigger('error', this);
        }
    }

    /*
     * Backbone defines this as: [This] performs a 'smart' update of the collection with the passed list of models.
     *
     * In general, we do not allow this to be called, since server models are supposed to be read only. However,
     * in some cases, internally, we need to add models to the collection, and wish to partake of the functionality
     * already defined by Backbone. So, if this is called with { _dxAllowSetPassthrough:true }, it will call
     * Backbone.Collection.set() normally.
     *
     * This is not simply a dxAdd function, since we need to support calls from within backbone back to model.set()
     * that may have been triggered by other actions we have taken.
     */
    function dxSet(models, options) {
        options = options || {};
        if (!options._dxAllowSetPassthrough) {
            operationNotAllowed();
        }

        assertModelsCompatible(models, this);
        return Backbone.Collection.prototype.set.call(this, models, _.extend(options, {
            merge: false,
            remove: false
        }));
    }

    /*
     * Backbone defines this as: parse is called by Backbone whenever a collection's models are returned by the server,
     * in fetch. The function is passed the raw response object, and should return the array of model attributes to be
     * added to the collection. The default implementation is a no-op, simply passing through the JSON response.
     * Override this if you need to work with a preexisting API, or better namespace your responses.
     *
     * This expects the response to always have a type attribute. If it is an ErrorResult, it gets reported through the
     * standard error handler. If it is a ListResult, we return just the result array. Otherwise we throw an error.
     */
    function dxParse(response) {
        if (!response || !response.type) {
           dx.fail('Got a response without a type.');
        } else if (response.type !== 'ListResult') {
            dx.fail('Got an unexpected type of response (' + response.type + ') in parse().');
        }

        return response.result;
    }

    /*
     * Entirely block the standard Backbone fetch() routine. We want users to call $$list(), as that has a more
     * constrained API, better matches the api we're providing for operations and rootOperations, and, more directly
     * maps to our schemas.
     */
    function dxFetch() {
        dx.fail('Do not call fetch() directly. Instead, call $$list().');
    }

    /*
     * Entirely block the standard Backbone create() routine. Creation is more complex for DSB models, and so should be
     * done through the $$create operations.
     */
    function dxCreate() {
        dx.fail('Do not call create() directly. Instead, call rootOps.' + this._dxInfo.baseType + '.$$create().');
    }

    /*
     * Removes all models from the collection, but leaves it 'live'.  This is used for testing purposes.
     */
    function dxEmpty() {
        Backbone.Collection.prototype.remove.call(this, this.models, {silent: true});
    }

    /*
     * Removes all models from the collection (not silently), removes the query parameters,
     * if any, and marks the collection as not ready, which means it must have another $$list() call in order to get
     * new models
     */
    function dxClear() {
        this._dxIsReady = false;
        this._queryParameters = undefined;
        Backbone.Collection.prototype.remove.call(this, this.models, {silent: true});
        this.trigger('reset', this);
    }

    /*
     * Given a model, this will either add it to the collection, if it should be in the collection, ignore it if it
     * shouldn't be in the collection (and isn't there already), or remove it if it shouldn't be in the collection and
     * is.  This takes into account any query parameters associated with the collection, and uses collection filters
     * if defined.
     *
     * Note that models can be neither added nor removed if this is not ready.
     */
    function dxAddOrRemove(model, options) {
        assertModelsCompatible(model, this);
        if (!this._dxIsReady) {
            return;
        }
        options = _.extend({
                _dxAllowSetPassthrough: true
            }, options);
        var self = this;
        var rootType = this._dxInfo.baseType;

        if (self._listingMode === LISTINGMODE_LISTING) {
            return;
        }

        var filter = context._filters[rootType];
        if (!filter) {
            if (self._dxInfo.paramDefs.dxFilterMode === dx.core.constants.LIST_TYPES.NONE) {
                dxSet.call(self, model, options);
                return;
            }

            filter = context._filters._uberFilter;
        }

        filter(this, model, function(placement) {
            if (model._dxDeleted) {
                /*
                 * Since some filters use asynchronous requests to determine the inclusion of an object,
                 * it is possible for an object to be deleted while a filter is executed.
                 * We need to make sure that even if the filter determines that the object should be
                 * included in the list, the collection discards deleted objects.
                 */
                return;
            }
            switch (placement) {
                case context._filters.INCLUDE:
                    dxSet.call(self, model, options);
                    break;
                case context._filters.EXCLUDE:
                    self._dxRemoveModel(model, options);
                    break;
                case context._filters.UNKNOWN:
                    if (self._listingMode === LISTINGMODE_IDLE) {
                        triggerDirty(self);
                    }
                    break;
                default:
                    dx.fail('Filter returned an invalid value.');
            }
        });
    }

    /*
     * Sets the autoPageRefresh property.
     */
    function setAutoPageRefresh(value) {
        this._autoPageRefresh = value;
    }

    /*
     * Return the autoPageRefresh property.
     */
    function getAutoPageRefresh() {
        return this._autoPageRefresh;
    }

    /*
     * Remove the models from this collection that are being obsoleted by the contents of the rawPropsArray. In
     * general, we remove the models that the collection currently contains that are not part of the rawPropsArray,
     * but if the rawPropsArray don't have a reference attribute, then we can't tell if the models are the same or not
     * so we reset.
     *
     * Return whether we are resetting the collection. This is true if we're removing all elements, or if
     * collection._resetOnList is true.
     */
    function removeUnneededModels(collection, rawPropsArray) {
        var resetting = false;

        if (rawPropsArray.length !== 0 && _.isUndefined(rawPropsArray[0].reference)) {
            Backbone.Collection.prototype.remove.call(collection, collection.models, {silent: true});
            resetting = true;
        } else {
            var newReferences = _.map(rawPropsArray, function(attributes) {
                return attributes.reference;
            });

            // Figure out which models to remove (by reference). reset if removing all
            var modelsToRemove = [];
            collection.each(function(model) {
                if (!_.contains(newReferences, model.id)) {
                    modelsToRemove.push(model);
                }
            });

            if (collection._resetOnList || modelsToRemove.length === collection.length) {
                resetting = true;
            }

            _.each(modelsToRemove, function(model) {
                Backbone.Collection.prototype.remove.call(collection, model, {silent: resetting});
            });
        }
        return resetting;
    }

    /*
     * Retrieve a set of models from the server, entirely replacing the contents of this collection with those models.
     * This is a reflection of the list standard operation found in Delphix schemas.  This takes a set of query
     * parameters as an argument, and will populate the collection with the results of that query.
     *
     * Note that if multiple requests are issued, this will only honor the last request sent. Models are added/removed
     * only when the last issued request returns. This also means that ready/error events are triggered and promises
     * resolved/rejected only once the last request issued returns.
     *
     * Parameters:
     *     parameters: An object hash containing the parameters to this list operation. For example, if this is a
     *         Container collection, you might call
     *             myCollection.$$list({
     *                 group: 'GROUP-1',
     *                 parent: 'CONTAINER-23'
     *             });
     *     successError: A standard object that contains a success and/or error callback routine.
     * Events:
     *     ready:  Triggered for the collection once all the models have been added and removed. Handler argument is
     *             the collection.
     *             Also triggered for each model marked as ready. Handler argument is a model.
     *     reset:  Triggered if this results in all the existing models being removed, or the _resetOnList flag has
     *             been set to true. Argument is the collection.
     *     remove: Triggered for each model removed, iff only some of the models are removed. Argument is the model.
     *     add:    Triggered for each added model, iff only some of the models were removed. Argument is the model.
     */
    function dxList(parameters, successError) {
        var sendableParams = context._checkAndConvertParameters(parameters, this._dxInfo.paramDefs.parameters);
        var self = this;
        var rootType = this._dxInfo.baseType;

        // No filter function. Complain so someone writes one, and blindly add the model
        if (dx.core.util.isNone(context._filters[rootType]) &&
            self._dxInfo.paramDefs.dxFilterMode === dx.core.constants.LIST_TYPES.CUSTOM) {
            dx.fail('No filter function found for collections of type ' + rootType + '. Add one to ' +
                 ' dx.core.data._filters. In the mean time, all models will be added to the collection.');
        }

        self._dxIsReady = false;
        self._dxIsErrored = false;
        // Keep track of latest outstanding request. We only honor a response if it came from the latest issued request.
        self._latestListToken++;
        var currListToken = self._latestListToken;

        self.sync('read', self, {
            parse: true,
            data: sendableParams,
            success: function(resp) {
                if (self._latestListToken !== currListToken) {
                    return; // Another list request has been issued
                }

                if (resp && resp.type === 'ErrorResult') {
                    var processedResult = context._newClientModel(resp.type);
                    processedResult.set(resp);
                    if (successError && successError.error) {
                        successError.error(processedResult);
                    } else {
                        context.reportErrorResult(processedResult);
                    }
                    self.trigger('error', self);
                    self._dxIsErrored = true;
                    return;
                }

                var resetting = false;
                self._queryParameters = dx.core.util.deepClone(parameters);
                self._listSuccessError = successError; // save for auto-relisting
                self._dxIsReady = true;
                self._listingMode = LISTINGMODE_LISTING;

                resp = self.parse(resp);

                resetting = removeUnneededModels(self, resp) || self._resetOnList;

                /*
                 * Add the new models.
                 */
                _.each(resp, function(attributes) {
                    var model = context._cache.getCachedModelFromProperties(attributes, {silent: resetting});
                    dxSet.call(self, model, {silent: resetting, _dxAllowSetPassthrough: true});
                });

                self._listingMode = LISTINGMODE_IDLE;

                // Report finishing events
                if (resetting) {
                    self.trigger('reset', self);
                }

                self.trigger('ready', self);

                if (successError && successError.success) {
                    successError.success();
                }
            },
            error: function(xhr) {
                if (self._latestListToken !== currListToken) {
                    return; // Another list request has been issued
                }
                var errorResult = context._convertXhrToErrorResult(xhr);
                context._handleErrorResult(errorResult, successError);
                self.trigger('error', self);
                self._dxIsErrored = true;
            }
        });

        // Return a promise that is resolved once the model is ready, and rejected if the model reports an error
        var deferred = new $.Deferred();
        var listenerContext = {};

        self.once('ready', function() {
            deferred.resolve(self);
            self.off(undefined, undefined, listenerContext);
        }, listenerContext);

        // don't set up the error handler if ready was already triggered
        if (deferred.state() === 'pending') {
            self.once('error', function() {
                deferred.reject(self);
                self.off(undefined, undefined, listenerContext);
            }, listenerContext);
        }

        return deferred.promise();
    }

    /*
     * Retrieve the last set of query parameters passed to $$list().  This is useful if you want to see what this
     * collection currently contains.
     */
    function getQueryParameters() {
        return this._queryParameters;
    }

    /*
     * ========================================
     * Collection creation
     * ========================================
     */

    /*
     * Returns a new DSB collection which is set to be a server collection.
     *
     * resetOnList: If true, $$list()'s will only trigger a single 'reset' event rather than individual 'add' and
     *              'remove' events. Otherwise this happens only when the $$list() fully replaces the contents of the
     *              collection.
     */
    function newServerCollection(typeName, resetOnList) {
        if (dx.core.util.isNone(typeName)) {
            dx.fail('To create a new collection, a type name must be provided.');
        }

        if (!isSchemaType(typeName)) {
            dx.fail(typeName + ' is not a known type with a list operation. Can not create this collection.');
        }

        var collection = new context._collectionConstructors[typeName]();
        collection.constructor = Backbone.Collection.extend(); // make clone() return an ordinary backbone collection.
        collection._resetOnList = !!resetOnList;

        return collection;
    }

    function operationNotAllowed() {
        dx.fail('Can not call this operation on a Server Collection.');
    }

    /*
     * ========================================
     * Utility functions
     * ========================================
     */

    function isSchemaType(typeName) {
        return !!context._collectionConstructors[typeName];
    }

    /*
     * Return true if the type is the same as baseType or is a subtype.
     */
    function isACompatibleType(type, baseType) {
        if (!context._modelConstructors[type]) {
            return false;
        }

        var typeDef = context._modelConstructors[type].prototype._dxSchema;
        while (typeDef) {
            if (typeDef.name === baseType) {
                return true;
            }
            typeDef = typeDef.parentSchema;
        }

        return false;
    }

    /*
     * Throws error if model (Backbone.Model or attributes) is not compatible with the specified type.
     */
    function assertModelCompatible(aModel, baseType) {
        var type;
        if (aModel instanceof Backbone.Model) {
            type = aModel.get('type');
        } else {
            dx.fail('Can not add an arbitrary set of attributes. Must pass a Backbone Model.');
        }

        if (!isACompatibleType(type, baseType)) {
            dx.fail('Can not add a model of type ' + type + ' to a collection with a base type of ' + baseType + '.');
        }
    }

    /*
     * Validates that all models are compatible with this collection's type.
     */
    function assertModelsCompatible(models, referenceModel) {
        if (dx.core.util.isNone(models)) {
            dx.fail('Can not call without a model.');
        }

        if (_.isArray(models)) {
            _.each(models, function(model) {
                assertModelCompatible(model, referenceModel._dxInfo.baseType);
            }, this);
        } else {
            assertModelCompatible(models, referenceModel._dxInfo.baseType);
        }
    }

    /*
     * Trigger a 'dirty' event, and if appropriate, set up another call to do a new list operation.
     */
    function triggerDirty(collection) {
        collection.trigger('dirty');
        if (collection.getAutoPageRefresh()) {
            setTimeout(function() {
                dxList.call(collection, collection.getQueryParameters(), collection._listSuccessError);
            }, 0);
        }
    }

    /*
     * ========================================
     * Actually do the work of this function
     * ========================================
     */

    context = context || this;
    context._collectionConstructors = context._collectionConstructors || {};

    _.each(schemas, function(schema, typeName) {
        if (schema.list) {
            // examine return values, in case the return type is not the same as the schema type
            var retObj = schema.list.return;
            var retItemsObj = retObj ? retObj.items : undefined;
            var collectionType = retItemsObj  ? retItemsObj.$ref : (retObj || {}).$ref;
            collectionType = collectionType || schema.name;

            context._collectionConstructors[typeName] = Backbone.Collection.extend({
                _dxInfo: {
                    baseType: collectionType,
                    paramDefs: schema.list
                },
                _dxIsReady: false,
                _dxIsErrored: false,
                _queryParameters: undefined,
                _autoPageRefresh: false,
                _listSuccessError: undefined,
                _listingMode: LISTINGMODE_IDLE,
                url: schema.root,
                _dxEmpty: dxEmpty,
                _dxRemoveModel: Backbone.Collection.prototype.remove,
                _dxAddOrRemove: dxAddOrRemove,
                model: function() {
                    dx.fail('Can not create a new model on a collection. Must use the cache.');
                },
                on: dxOn,
                add: operationNotAllowed,
                remove: operationNotAllowed,
                set: dxSet,
                reset: operationNotAllowed,
                push: operationNotAllowed,
                pop: operationNotAllowed,
                unshift: operationNotAllowed,
                shift: operationNotAllowed,
                parse: dxParse,
                fetch: dxFetch,
                create: dxCreate,
                $$list: dxList,
                _latestListToken: 0,
                _resetOnList: false,
                clear: dxClear,
                getQueryParameters: getQueryParameters,
                setAutoPageRefresh: setAutoPageRefresh,
                getAutoPageRefresh: getAutoPageRefresh
            });
        }
    });

    context._newServerCollection = newServerCollection;
};

})();
