/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright (c) 2014, 2015 by Delphix. All rights reserved.
 */

/*global dx, _ */

'use strict';

dx.namespace('dx.test.mockServer._filters');

/*
 * Defines a set of filter helper functions for delphix schema root types to be used by the Mock Server.
 * New filters should be added here, with each filter named by the root type.
 *
 * mockCollectionFilters differ from level2-filters in a number of ways:
 * 1. These are synchronous, as the mockServer is written synchronously. level2-filters are async.
 * 2. These deal with plain objects, while level2-filters must deal with Backbone models.
 * 3. These have a global view of the objects in the system, and can thus deal with things like paging, whereas
 *    level2-filters can not.
 *
 * Many filters can be autogenerated from the schemas and schema annotations defined in level1-schema.js. These use the
 * uberFilter. However, there are still some types which cannot be autogenerated due to complex logic which cannot be
 * inferred from the schema.
 *
 * Each filter function takes in a collection and a hash of query parameters, and will return the filtered version of
 * the collection.
 *
 * Note: These filters should be kept in sync with level2-filters.
 */
(function() {

var DATE_PROPS = ['fromDate', 'startDate', 'toDate', 'endDate'];

function missingObject(type, reference) {
    dx.fail('The ' + type + ' (' + reference + ') does not exist in the mock server and is needed to filter your ' +
            '$$list operation.');
}

// Parse the 'mapsTo' property for the query parameter and follow the data mapping chain
function followDataMapping(object, mapsTo, parsedSchemas) {
    var parts = mapsTo.split('.');

    // We know the last part will be property to compare. Anything before that will be a chain of object dereferencing
    var finalAttrName = parts.pop();

    var currObj = object;
    _.each(parts, function(part) {
        var type = parsedSchemas[currObj.type].properties[part].referenceTo;

        var newObj = dx.test.mockServer.getObject(currObj[part], type);
        if (!newObj) {
            missingObject(type, currObj[part]);
        }

        currObj = newObj;
    });

    return { object: currObj, attrName: finalAttrName };
}

/*
 * Helper for a single query parameter. Will follow a data mapping and check that the qParam value matches the object's
 * property value.
 */
function checkSimpleProp(qParamVal, qParamName, objectSchema, object, parsedSchemas) {
    var mapsTo = objectSchema.list.parameters[qParamName].mapsTo;
    if (!mapsTo) {
        dx.fail('No mapsTo property found for query parameter ' + qParamName + '.');
    }

    var pair = followDataMapping(object, mapsTo, parsedSchemas);
    var finalObj = pair.object;
    var finalAttrName = pair.attrName;

    return qParamVal === finalObj[finalAttrName];
}

/*
 * Helper for a single query parameter. Will follow a data mapping and check a date-related query parameter.
 */
function checkDateProp(qParamVal, qParamName, objectSchema, object, parsedSchemas) {
    var mapsTo = objectSchema.list.parameters[qParamName].mapsTo;
    if (!mapsTo) {
        dx.fail('No mapsTo property found for query parameter ' + qParamName);
    }

    if (!_.contains(DATE_PROPS, qParamName)) {
        dx.fail('Expected a date related query parameter (' + DATE_PROPS.join(', ') + ') but found: ' + qParamName);
    }

    var inequalityType = objectSchema.list.parameters[qParamName].inequalityType;

    if (_.isUndefined(inequalityType)) {
        dx.fail('Date property "' + qParamName + '" missing "inequalityType" schema property');
    }

    var pair = followDataMapping(object, mapsTo, parsedSchemas);
    var finalObj = pair.object;
    var finalAttrName = pair.attrName;

    // Since we are at the mockServer level, the query parameters passed in may be timestamps, not Date objects
    if (!_.isDate(qParamVal)) {
        qParamVal = new Date(qParamVal);
    }

    // Handle the case where this is a timestamp string as well as a Date object
    var objAttrVal = finalObj[finalAttrName];
    if (_.isString(objAttrVal)) {
        objAttrVal = new Date(objAttrVal);
    }

    if (dx.core.util.isNone(objAttrVal)) {
        return false;
    }

    if (_.contains(['fromDate', 'startDate'], qParamName)) {
        if (objAttrVal.getTime() < qParamVal.getTime()) {
            return false;
        }
    } else if (objAttrVal.getTime() > qParamVal.getTime()) { // toDate or endDate
        return false;
    }

    if (inequalityType === dx.core.constants.INEQUALITY_TYPES.STRICT && objAttrVal.getTime() === qParamVal.getTime()) {
        return false;
    }

    return true;
}

/*
 * Helper to determine if a mock server object should be included given it's index and paging parameters.
 * Note that this assumes not specifying a page size implicitly sets it to a particular size (generally 25),
 * while specifying 0 means 'all'.
 */
function checkPageSize(qParams, objectIndex, collectionLength) {
    var start, end, pageSize, pageOffset;

    if (qParams.pageSize === 0) {
        return true;
    }

    pageSize = qParams.pageSize || 25;
    pageOffset = qParams.pageOffset || 0; // No pageOffset gives you the page with the most recent data

    if (pageSize < 0) {
        dx.fail('pageSize must be a positive integer');
    }

    if (pageOffset >= 0) {
        end = collectionLength - pageSize * pageOffset - 1;
        start = Math.max(0, end - pageSize + 1);
    } else {
        // Negative offset takes the page from the older end of the collection, with -1 being the oldest
        start = pageSize * -(pageOffset + 1);
        end = Math.min(collectionLength - 1, start + pageSize - 1);
    }

    return objectIndex >= start && objectIndex <= end;
}

/*
 * Check an array of query parameters against an object.
 */
function checkProps(qParamNamesToCheck, qParams, object, objectSchema, parsedSchemas) {
    return _.every(qParamNamesToCheck, function(qParamName) {
        if (!_.has(qParams, qParamName)) {
            return true;
        }

        var dateParams = ['fromDate', 'startDate', 'toDate', 'endDate'];
        var qParamVal = qParams[qParamName];

        if (_.contains(dateParams, qParamName)) {
            return checkDateProp(qParamVal, qParamName, objectSchema, object, parsedSchemas);
        } else {
            return checkSimpleProp(qParamVal, qParamName, objectSchema, object, parsedSchemas);
        }
    });
}

/*
 * One filter to rule them all, one filter to find them,
 * One filter to bring them all and in the darkness bind them.
 *
 * In the days of old there were many filters freely roaming the land. At the end of the second age, schema annotations
 * were introduced into level1-schemas.js. This gave the dark lord all the tools he needed to corral the filters into a
 * single uberFilter, thus beginning a period of darkness and code maintainability. However, a few misfit filters
 * managed to escape the all seeing gaze of the dark lord, their logic simply too complex to be handled by the
 * uberFilter.
 */
function uberFilter(collection, qParams, collectionType, parsedSchemas) {
    parsedSchemas = parsedSchemas || dx.core.data.parsedSchemas;
    var objectSchema = parsedSchemas[collectionType];

    return _.filter(collection, function(object) {
        return checkProps(_.keys(qParams), qParams, object, objectSchema, parsedSchemas);
    });
}

/*
 * uberFilter needs the type to get schema information. This wraps uberFilter and returns a function that conforms to
 * the signature expected by mockServer.
 */
function makeUberFilter(type) {
    return function wrappedUberFilter(collection, qParams) {
        return uberFilter(collection, qParams, type);
    };
}

/*
 * Wraps an individual filter function to take care of logic around paging.
 */
function maybeAddPagingToFilter(type, filterFunc) {
    var supportsPaging = 'pageSize' in dx.core.data.parsedSchemas[type].list.parameters;

    return function wrappedFilter(collection, qParams) {
        var pagingParams,
            result = collection;

        // Separate paging parameters from other parameters
        pagingParams = _.pick(qParams, 'pageSize', 'pageOffset');
        qParams = _.omit(qParams, 'pageSize', 'pageOffset');

        result = filterFunc(collection, qParams);

        if (supportsPaging) {
            result = _.filter(result, function(object, index) {
                return checkPageSize(pagingParams, index, result.length);
            });
            // The most recent result should be the first (index 0) in the list
            result.reverse();
        }

        return result;
    };
}

_.extend(dx.test.mockServer._filters, {
    _uberFilter: uberFilter,
    makeUberFilter: makeUberFilter,
    missingObject: missingObject,
    checkProps: checkProps,
    maybeAddPagingToFilter: maybeAddPagingToFilter
});

})();
