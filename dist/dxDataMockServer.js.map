{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/mockServer/AbstractServer.js",
    "src/mockServer/ApiServer.js",
    "src/mockServer/ServerCore.js",
    "src/mockServer/mockFilters.js",
    "src/mockServer/mockServer.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxlCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _ */\n\n'use strict';\n\ndx.namespace('dx.test');\n\n/*\n * This is an abstract supertype which provides common behavior for starting and stopping a mock server as well as\n * jQuery compatible behavior for receiving calls to $.ajax() making calls to ServerCore, and making calls back to\n * through the jQuery callbacks.  What this doesn't provide is exactly how the server reacts between the return from\n * the ServerCore call(s) and making the callbacks to the jQuery callbacks. That is the primary area for subtypes to\n * augment this.\n *\n * When a server is started, it replaces the standard jQuery ajax function with its own, and thereafter processes those\n * queries. It redirects the call as appropriate to the ServerCore, and then asks subtypes to decide what to do with\n * the Result that comes back from that.\n *\n * This provides a set of routines for subtypes to use to process and ultimately deliver results to the callers.\n */\n(function() {\n\nvar JSON_MIME_TYPE = 'application/json';\nvar TEXT_MIME_TYPE = 'text/plain';\n\n// Mapping of HTTP status codes to text. https://www.ietf.org/rfc/rfc2616.txt\nvar HTTP_STATUS_TEXT = {\n    100: 'Continue',\n    101: 'Switching Protocol',\n    200: 'OK',\n    201: 'Created',\n    202: 'Accepted',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    306: '(Unused)',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'Internal Server Error'\n};\n\n/*\n * Replacement for jQuery's ajax function.  This handles these aspects of jquery's behavior:\n * It will then pass the url and settings.data on to ServerCore, and then ask subtypes to deal with the Result.\n * This also does provide the notification long poll support.\n */\nfunction replacementAjaxHandler(url, settings) {\n    var self = this;\n\n    // parameters can be $.ajax(settings) or $.ajax(url, settings)\n    if (_.isObject(url)) {\n        settings = url;\n        url = settings.url;\n    }\n    var messageBody = settings.data;\n    var isNotificationCall = url.indexOf(self._notificationUrl) !== -1;\n    var method = settings.type || 'GET';    // default to GET if needed.\n    method = method.toUpperCase();\n\n    self._ajaxCallId++;\n    self._reportDebug(self._ajaxCallId, 'Receive ' + method + ':' + url);\n\n    if (isNotificationCall) {\n        self._pendingLongpolls.push(addToResult({}, settings, self._ajaxCallId));\n    } else {\n        var result = self[method](url, messageBody);\n\n        if (result.statusCode === self.UNKNOWN_URL_STATUS) {\n            self._handleUnknownUrl(method, url, settings);\n        } else {\n            self._handleResult(addToResult(result, settings, self._ajaxCallId));\n        }\n    }\n}\n\n// Given a Response object, create a duck-typed jQuery XHR\nfunction PseudoXhr(result) {\n    var self = this;\n\n    self.readyState = 4;\n    self.status = result.statusCode;\n    self.statusText = HTTP_STATUS_TEXT[result.statusCode];\n\n    // In the majority of cases, responseText is never evaluated, so lazily compute it (since it may involve stringify)\n    Object.defineProperty(self, 'responseText', {\n        get: function() {\n            if (result.dataText) {\n                return result.dataText;\n            }\n\n            if (_.isString(result.data)) {\n                return result.data;\n            }\n\n            return JSON.stringify(result.data);\n        },\n        enumerable: true\n    });\n}\n\n// dxData calls this under error circumstances to check the data type of the return\nPseudoXhr.prototype.getResponseHeader = function getResponseHeader(header) {\n    var self = this;\n\n    if (header.toLowerCase() === 'content-type') {\n        if (parseJSON(self.responseText) instanceof Error) {\n            return TEXT_MIME_TYPE;\n        }\n        return JSON_MIME_TYPE;\n    }\n\n    return '';\n};\n\n// Augment a result object with other (private) information that this will need later to deliver the Result to callbacks\nfunction addToResult(result, settings, callId) {\n    result.async = settings.async;\n    result.dataType = settings.dataType && settings.dataType.toUpperCase();\n    result.success = settings.success;\n    result.error = settings.error;\n    result.status = settings.statusCode && settings.statusCode[result.statusCode];\n    result.callId = callId;\n\n    return result;\n}\n\n/*\n * Overridable routine that lets a subtype do something with each result.\n * Expected parameters: result\n */\nfunction handleResult() {\n    dx.fail('handleResult() must be overridden.');\n}\n\n/*\n * Overridable routine to cope with a call that the ServerCore couldn't handle\n * Expected parameters: method, url, settings\n */\nfunction handleUnknownUrl() {\n    dx.fail('handleUnknownUrl() must be overridden.');\n}\n\n/*\n * Given a result (decorated with the information from addToResult()) process it and deliver to the client.\n */\nfunction deliverResult(server, result) {\n    if (result.statusCode >= 200 && result.statusCode < 300 || result.statusCode === 304) {\n        /*\n         * Most of the time, the mock server returns data as a JavaScript object (not truly JSON). However, one can add\n         * a JavaScript file as a resource and retrieve it, in which case we will receive a true JSON value.  If the\n         * client told us it was expecting JSON data, mimic jQuery's behavior, parse the JSON and return the result.\n         */\n        if (result.dataType === 'JSON' && _.isString(result.data)) {\n            var parsing = parseJSON(result.data);\n            if (parsing instanceof Error) {\n                invokeCallbacks(server, result, 'parsererror', parsing);\n                return;\n            } else {\n                result.dataText = result.data;\n                result.data = parsing;\n            }\n        // if the client is asking for a script, mimic jQuery and eval it.\n        } else if (result.dataType === 'SCRIPT') {\n            var evalResult = evalJavaScript(result.data);\n            if (evalResult instanceof Error) {\n                invokeCallbacks(server, result, 'parsererror', evalResult);\n                return;\n            }\n        }\n        invokeCallbacks(server, result, 'success');\n    } else {\n        invokeCallbacks(server, result, 'error');\n    }\n}\n\nfunction invokeCallbacks(server, result, status, errorObject) {\n    var xhr = new PseudoXhr(result);\n    var callbacks = [].concat(result.status);\n    if (status === 'success') {\n        _.each(callbacks.concat(result.success), function(cb) {\n            if (cb) {\n                cb(result.data, 'success', xhr);\n            }\n        });\n    } else {\n        _.each(callbacks.concat(result.error), function(cb) {\n            if (cb) {\n                cb(xhr, status, errorObject || xhr.statusText);\n            }\n        });\n    }\n\n    server._reportDebug(result.callId, 'Deliver ' + status);\n}\n\n/*\n * Parse a JSON string and either return the parsed result or an Error instance.  This is done as a separate routine\n * to limit the impact of the try-catch block which in some browsers makes the routine something it can't optimize.\n */\nfunction parseJSON(jsonString) {\n    try {\n        return JSON.parse(jsonString);\n    } catch (error) {\n        return error;\n    }\n}\n\n/*\n * Eval a string as JavaScript.  This is in a separate routine to limit the non-optimizability of the try-catch block.\n */\nfunction evalJavaScript(javaScriptString) {\n    try {\n        $.globalEval(javaScriptString);\n    } catch (error) {\n        return error;\n    }\n}\n\nfunction findNotificationUrlBase(schemas) {\n    var notificationSchema = _.find(schemas, function(schema) {\n        return schema.name === 'Notification';\n    });\n\n    if (!notificationSchema || !notificationSchema.root) {\n        dx.fail('Schemas do not include a Notification type.');\n    }\n\n    return notificationSchema.root;\n}\n\n/*\n * Handle longpoll notifications. If there are notifications to be delivered and there are open longpoll\n * requests, then deliver those results to the longpoll calls.\n */\nfunction processNotifications(server) {\n    if (server.getCollectionLength('Notification') && server._pendingLongpolls.length > 0) {\n        var result = server.GET(server._notificationUrl);\n        server.clearCollection('Notification');\n\n        _.each(server._pendingLongpolls, function(resultExtras) {\n            var fullResult = _.extend(_.clone(result), resultExtras);\n            server._handleResult(fullResult);\n        });\n        server._pendingLongpolls = [];\n    }\n}\n\n/*\n * Report a debug message\n */\nfunction reportDebug(server, callId, message, data) {\n    if (!server.debug) {\n        return;\n    }\n\n    // Special case OK and List results. Just show the returned data\n    if (data && data.result) {\n        data = data.result;\n    }\n    var jsonData = data ? ' ' + JSON.stringify(data) : '';\n    if (jsonData.length > 100) {\n        jsonData = jsonData.substr(0, 100) + '...';\n    }\n\n    dx.debug('Call ' + callId + ': ' + message + jsonData);\n}\n\n/*\n * Start the server, by redirecting all jquery ajax calls to it.\n */\nfunction startMockServer() {\n    var self = this;\n    if (dx.core.ajax.hasAjaxHandler(self)) {\n        dx.fail('This server is already started.');\n    }\n\n    // create a unique function as our handler, and make sure it has ourself as its 'this'\n    dx.core.ajax.registerAjaxHandler(this, replacementAjaxHandler.bind(self));\n}\n\n/*\n * Turn off the server, restoring ajax traffic to wherever it would have gone before.\n */\nfunction stopMockServer() {\n    var self = this;\n    if (!dx.core.ajax.hasAjaxHandler(self)) {\n        dx.fail('This server has not been started.');\n    }\n\n    dx.core.ajax.removeAjaxHandler(self);\n}\n\nfunction AbstractServer(schemas) {\n    var self = this;\n    if (!(self instanceof AbstractServer)) {\n        dx.fail('Must call AbstractServer() with new.');\n    }\n    if (!_.isObject(schemas)) {\n        dx.fail('Must pass a map of schemas when constructing a server.');\n    }\n\n    var server = new dx.test.ServerCore(schemas);\n\n    _.extend(server, {\n        _pendingLongpolls: [],\n        _notificationUrl: findNotificationUrlBase(schemas),\n        _ajaxCallId: 0,\n        debug: false,\n        _handleUnknownUrl: handleUnknownUrl,\n        _handleResult: handleResult,\n        _processNotifications: _.partial(processNotifications, server),\n        _deliverResult: _.partial(deliverResult, server),\n        _reportDebug: _.partial(reportDebug, server),\n        _addToResult: addToResult,\n        start: startMockServer,\n        stop: stopMockServer\n    });\n\n    return server;\n}\n\ndx.test.AbstractServer = AbstractServer;\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _ */\n\n'use strict';\n\ndx.namespace('dx.test');\n\n/*\n * ApiServer is a server is meant to be run in an interactive session within a browser. For example, you may want to\n * run your UI using the mock data in the server, but want to rely on fetching of other server resources from a real\n * server.\n * In general, what the ApiServer does is defer to the ServerCore to handle api calls, but when the ServerCore doesn't\n * know what to do with that call, this will then direct the query to the original $.ajax handler which will then\n * contact the real server.\n * This also will deliver results from the server core asynchronously.\n *\n * To use ApiServer, simply do the following:\n *    var server = new dx.test.ApiServer(schemas);\n *    server.start();\n *\n * It is best if this is done before anything else has started interacting with the network.\n */\n(function() {\n\n/*\n * If the MockServer can't figure out what to do with this call, hand it off to the real server.\n */\nfunction handleUnknownUrl(server, method, url, settings) {\n    var config = Object.assign({\n        url: url,\n        method: method\n    }, settings)\n    var baseHandler = dx.core.ajax.getAjaxBaseHandler();\n    baseHandler.handler(config);\n}\n\n/*\n * When a callback is ready to be dealt with, run it in a setTimeout() call so it will happen\n * asynchronously from the caller's standpoint.\n */\nfunction handleResult(server, result) {\n    setTimeout(function() {\n        server._deliverResult(result);\n        server._processNotifications();\n        $.event.trigger('ajaxComplete');\n    }, 0);\n}\n\nfunction ApiServer(schemas) {\n    var self = this;\n    if (!(self instanceof ApiServer)) {\n        dx.fail('Must call ApiServer() with new.');\n    }\n\n    var server = new dx.test.AbstractServer(schemas);\n    server._handleUnknownUrl = _.partial(handleUnknownUrl, server);\n    server._handleResult = _.partial(handleResult, server);\n\n    function performThenCheckNotifications(origFunction) {\n        origFunction.apply(server, _.rest(arguments));\n        server._processNotifications();\n    }\n\n    server.createObjects = _.wrap(server.createObjects, performThenCheckNotifications);\n    server.updateObjects = _.wrap(server.updateObjects, performThenCheckNotifications);\n    server.deleteObjects = _.wrap(server.deleteObjects, performThenCheckNotifications);\n\n    return server;\n}\n\ndx.test.ApiServer = ApiServer;\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _ */\n\n'use strict';\n\ndx.namespace('dx.test');\n\n/*\n * ServerCore provides support for all the data management required of a Delphix Schema-based server (storing objects,\n * responding to operations). It is intended to be used as a base type for various mock servers, allowing subtypes to\n * provide specialized server behavior without needing to re-invent the data and operation management.\n * ServerCore provides support for storing Delphix Schema defined singleton objects and collections of objects, as\n * well as support for the operations defined by those schemas, including  standard operations (read, list, create,\n * update, delete), object operations, and root operations.\n *\n * DATA\n *      createObjects()\n *      updateObjects()\n *      deleteObjects()\n *\n * These three routines add, update and delete objects and singletons in the server, respectively. By default, each\n * also creates the appropriate Notification objects (e.g. object creation notifications) for non-singleton objects,\n * though this can be overridden with a second argument.  The first argument to each can be either an object or an\n * array.\n *\n * When it is an object, it must have this structure:\n *    {\n *        TypeName : [ {\n *            { ... properties ... },\n *            { ... properties ... },\n *            ...\n *        } ],\n *        TypeName : { ... properties ... },\n *        ...\n *    }\n * Each of the \"{ ... properties ... }\" in the above description is a collection of properties for a particular\n * object instance as defined by the corresponding schema (but it need not be all the properties).\n * TypeName is either a singleton type name, or the name of a type that has a root property or a type descended from\n * a type with a root property.\n * If the individual objects do not have a type property, one will be added using the TypeName value.\n *\n * When it is an array, then it must have this structure:\n *    [{ ... properties ... }, { ... properties ... }, ...]\n *\n * There are some special cases for each of the three functions. In particular:\n *  - createObjects() will automatically add a generated reference property if the object type allows it and one isn't\n *                    provided in the \"{ ... properties ... }\" declaration\n *  - updateObjects() requires that there be a reference property in each object declaration.\n *  - deleteObjects() Requires a reference property. It can also accept an array of raw object references rather than\n *                    a whole object definition when the argument is an array.\n *\n * Note that these do not do full validation of the values passed in, so if dx.core.data calls fail reporting that\n * invalid properties were received, you should check your object definitions.\n *\n *      getSingleton()\n *      getObject()\n *      getCollection()\n *      clearCollection()\n *      getCollectionLength()\n *\n * These provide access to copies of the objects within the server.\n *\n * OPERATIONS\n *      addResources()\n *\n * This is used to register values that should be returned when a particular URL is GET'ed from the server.\n *\n *      addStandardOpHandlers()\n *      addStandardOpHandler()\n *      addRootOpHandlers()\n *      addRootOpHandler()\n *      addObjectOpHandlers()\n *      addObjectOpHandler()\n *\n * These are used to set up handlers for Standard Operations (list, read, create, update, delete), root operations and\n * object operations as defined by the schemas. The plural forms all take arguments in this form:\n *    {\n *        RootTypeName : {\n *            opName: function() {},\n *            ...\n *        },\n *        ...\n *    }\n * After the operation handler has been installed, any call to that operation on the server will invoke the handler.\n * Note that if a handler already exists in the server, a second addFooOperation call will replace the first.\n * The singular forms all take arguments in this form:\n *    addFooOperation(RootTypeName, operationName, function() {});\n *\n * The handlers take one of the following signatures:\n *    objectHandler(reference, payload, Result, server)\n *        This is for object operations, read, update and delete standard operations.\n *    otherHandler(payload, Result, server);\n *        This is for root operations, list and create standard ops, and singleton read, update and create operations.\n *\n *        reference: The reference of the object being manipulated\n *        payload: The payload of the call (or query parameters)\n *        Result: A constructor function for returning a value. See below\n *        server: A reference to the server making this call to the routine.\n *\n * Each of these functions must return either an arbitrary value, or a Result instance.  If a non-Result instance is\n * returned, the server assumes that it is a successful result, and calls new Result.OkResult(returnValue) for you.\n *\n *     Result(statusCode, data)\n *     Result.OkResult(okResultResult)\n *     Result.ListResult(listResultResult)\n *     Result.ErrorResult(statusCode, errorResultError)\n *     Result.MissingObjResult(type, reference, operation)\n *\n * These constructor functions generate Result instances with an HTTP Status Code and data to be returned to the caller.\n * Result() is the most generic and returns in the body whatever is in the second parameter.\n *\n * URL ACCESS\n *\n *     GET(url, parameters)\n *     POST(url, payload)\n *     DELETE(url, payload)\n *\n * These three routines let you do the equivalent of an HTTP GET, POST or DELETE on the server to the specified URL\n * with the named parameters or payload.  Each returns an object with a statusCode and data property. If the specified\n * url isn't supported by the server, then the return value is equivalent to new Result(server.UNKNOWN_URL_STATUS,\n * undefined);\n */\n(function() {\n\nvar OBJECT_OPERATION_REGX = new RegExp('(^.*)/([^/]+)/([^/]+)(\\\\?[^/]+)?$');   // anything/objref/operation?params\nvar OBJECT_READ_UPDATE_DELETE_REGEX = new RegExp('(^.*)/([^/]+)$');       // anything/something\nvar INLINE_REF = '/{ref}/';\nvar TRAILING_REF = '/{ref}';\nvar START_REF = 1000;\nvar STANDARD_OPERATONS = ['list', 'read', 'create', 'update', 'delete'];\n\n/*\n * Creates a set of objects in the mock server that can be accessed and manipulated by other operations on the mock\n * server.\n *\n * The parameters for this are discussed in the header comment to this file.\n *\n * Note:\n *   * In all cases, if the object type allows for a reference property, and that is not included in the object\n *     structure, then this will automatically add one.\n *   * If the object type has a reference, then a corresponding CREATE notification object will be automatically created\n *     unless skipNotifications is true.\n *   * You can \"create\" a singleton with this call. In that case, it will simply behave the same as an update.\n */\nfunction createObjects(server, newObjects, skipNotifications) {\n    return processArgumentsWithHandler(newObjects, skipNotifications, _.partial(createObject, server));\n}\n\n/*\n * Given an object, do the following:\n *   - Convert its properties to a JSON-compatible format\n *   - Make sure it is a known schema object type\n *   - Make sure it is a singleton or belongs to a type with a root property\n *   - Add a reference  if appropriate\n *   - Add the object to the mock server's internal cache of objects, replacing any instance already there\n *   - Generate object creation or singleton update notifications if appropriate\n */\nfunction createObject(server, newObject, skipNotification) {\n    if (!newObject.type) {\n        dx.fail('No type property found on object.', newObject);\n    }\n\n    var schema = server._schemasByName[newObject.type];\n    if (!schema) {\n        dx.fail(newObject.type + ' is not a known schema type.');\n    }\n\n    if (schema.singleton) {\n        server._singletons[newObject.type] = newObject;\n\n        if (!skipNotification) {\n            postNotifications(server, [{\n                type: 'SingletonUpdate',\n                objectType: newObject.type\n            }]);\n        }\n    } else {\n        var rootType = getRootTypeForObject(schema, server._schemasByName);\n        var shouldHaveReference = !!getPropDef(schema, 'reference', server._schemasByName);\n\n        if (!rootType) {\n            dx.fail(newObject.type + ' is not a type descended from one with a root property.');\n        }\n\n        server._objects[rootType] = server._objects[rootType] || [];\n        server._objects[rootType].push(newObject);\n\n        if (shouldHaveReference && !newObject.reference) {\n            newObject.reference = newObject.type.toUpperCase() + '-' + server._nextReference;\n            server._nextReference++;\n        }\n\n        // Notifications only make sense for an object with a reference\n        if (newObject.reference && !skipNotification) {\n            postNotifications(server, [{\n                type: 'ObjectNotification',\n                eventType: 'CREATE',\n                objectType: newObject.type,\n                object: newObject.reference\n            }]);\n        }\n\n        return newObject.reference;\n    }\n}\n\n/*\n * Updates a set of objects in the mock server.\n *\n * The parameters for this are discussed in the header comment to this file.\n *\n * Note:\n *   * All non-singleton objects MUST have a reference property set.\n *   * If the object type has a reference or is a singleton, then a corresponding UPDATE notification object will be\n *     automatically created unless skipNotifications is true.\n */\nfunction updateObjects(server, objectsToUpdate, skipNotifications) {\n    processArgumentsWithHandler(objectsToUpdate, skipNotifications, _.partial(updateObject, server));\n}\n\nfunction updateObject(server, newObject, skipNotification) {\n    var schema = server._schemasByName[newObject.type];\n\n    if (schema && schema.singleton) {\n        updateObjectProperties(server, getSingleton(server, newObject.type), newObject);\n\n        if (!skipNotification) {\n            postNotifications(server, [{\n                type: 'SingletonUpdate',\n                objectType: newObject.type\n            }]);\n        }\n    } else {\n        if (!newObject.reference) {\n            dx.fail('Can not update an object without at least a reference.');\n        }\n        var existing = getObject(server, newObject.reference);\n\n        if (!existing) {\n            dx.fail('There is no object with the reference ' + newObject.reference + ' to update.');\n        }\n\n        updateObjectProperties(server, existing, newObject);\n\n        if (!skipNotification) {\n            postNotifications(server, [{\n                type: 'ObjectNotification',\n                eventType: 'UPDATE',\n                objectType: existing.type,\n                object: existing.reference\n            }]);\n        }\n    }\n}\n\n/*\n * Overlays the target with the new properties while being aware of the fact that objects that have no schema type\n * associated with them should be treated as an \"atomic\" value and not overlaid but rather replaced as a unit.\n */\nfunction updateObjectProperties(server, targetObject, newProperties) {\n    _.each(newProperties, function(propval, propname) {\n        if (_.isObject(propval)) {\n            var schema = server._schemasByName[targetObject.type];\n            var propDef = getPropDef(schema, propname, server._schemasByName);\n\n            if (propDef && propDef.$ref) {\n                if (!_.isObject(targetObject[propname])) {\n                    targetObject[propname] = {};\n                }\n                updateObjectProperties(server, targetObject[propname], propval);\n                propval = targetObject[propname];\n            }\n        }\n        targetObject[propname] = propval;\n    });\n\n    return targetObject;\n}\n\n/*\n * Deletes a set of objects in the mock server.\n *\n * The parameters for this are discussed in the header comment to this file.\n * In addition, if the objectsToDelete is an array, you can simply specify an array of references:\n *    deleteObjects(['REF-1', 'REF-2', 'REF-3'...])\n * This is, far and away, the most common use of this.\n *\n * Note:\n *   * This will throw an error if you try to delete a Singleton.\n *   * All objects MUST have a reference property set.\n *   * A corresponding DELETE notification object will be automatically created unless skipNotifications is true.\n */\nfunction deleteObjects(server, objectsToDelete, skipNotifications) {\n    processArgumentsWithHandler(objectsToDelete, skipNotifications, _.partial(deleteObject, server));\n}\n\nfunction deleteObject(server, doomedObjectOrRef, skipNotifications) {\n    var targetReference = doomedObjectOrRef;\n\n    if (_.isObject(doomedObjectOrRef)) {\n        targetReference = doomedObjectOrRef.reference;\n    }\n\n    if (!targetReference) {\n        dx.fail('No reference provided to identify the object to delete.');\n    }\n\n    if (isSingleton(server, targetReference)) {\n        dx.fail('Can not delete singletons (' + targetReference + ' is a singleton).');\n    }\n\n    var deletedIt = _.find(server._objects, function(objectsArray) {\n        return _.find(objectsArray, function(anObject, index) {\n            if (anObject.reference === targetReference) {\n                objectsArray.splice(index, 1);\n\n                if (!skipNotifications) {\n                    postNotifications(server, [{\n                        type: 'ObjectNotification',\n                        eventType: 'DELETE',\n                        objectType: anObject.type,\n                        object: anObject.reference\n                    }]);\n                }\n\n                return true;\n            }\n        });\n    });\n\n    if (!deletedIt) {\n        dx.fail('Could not find ' + targetReference + ' to delete it.');\n    }\n}\n\n/*\n * Routine that process arguments to several input routines in a uniform way.  The arguments may be in one of two\n * forms:\n *    [{ ... properties ... }, { ... properties ... } ...]\n *  or\n *    {\n *        RootTypeName: [{ ... properties ... }, { ... properties ... } ...],\n *        RootTypeName: [{ ... properties ... }, { ... properties ... } ...],\n *        ...\n *    }\n * This will walk through each set of object properties, and call the specified handler with that set of properties\n * and the skipNotifications parameter.  In the case of the latter style, a type property will be added to each\n * individual object if it does not already have one.\n */\nfunction processArgumentsWithHandler(objectsToProcess, skipNotifications, handler) {\n    var copyOfObjects = deepClone(objectsToProcess);\n    var result = [];\n\n    if (_.isArray(copyOfObjects)) {\n        for (var index = 0; index < copyOfObjects.length; index++) {\n            result.push(handler(copyOfObjects[index], skipNotifications));\n        }\n    } else {\n        _.each(copyOfObjects, function(objectOrArray, typeName) {\n            if (_.isArray(objectOrArray)) {\n                for (var ctr = 0; ctr < objectOrArray.length; ctr++) {\n                    var anObject = objectOrArray[ctr];\n                    anObject.type = anObject.type || typeName;\n                    result.push(handler(anObject, skipNotifications));\n                }\n            } else {\n                objectOrArray.type = objectOrArray.type || typeName;\n                result.push(handler(objectOrArray, skipNotifications));\n            }\n        });\n    }\n\n    return result;\n}\n\n/*\n * Helper function to post an array of notifications.\n */\nfunction postNotifications(server, notifications) {\n    server.createObjects({\n        Notification: notifications\n    }, true);\n}\n\n/*\n * Returns the object with the specified reference, or undefined if no such object. If a type is specified, this may\n * use a faster algorithm to look up the object. This does not return singletons.\n */\nfunction getObject(server, objectRef, typeName) {\n    if (typeName) {\n        var schema = server._schemasByName[typeName];\n        if (!schema) {\n            dx.fail(typeName + ' is not a known type.');\n        }\n        var rootTypeName = getRootTypeForObject(schema, server._schemasByName);\n        if (!rootTypeName) {\n            dx.fail('Can only ask for objects in collections with a root property with getObject().');\n        }\n        if (rootTypeName !== schema.name) {\n            dx.fail('Must specify the root type (' + rootTypeName + ') if a type is specified to getObject().');\n        }\n\n        return _.find(server._objects[typeName], function(obj) {\n            return obj.reference === objectRef;\n        });\n    }\n\n    var matchedObject;\n    _.find(server._objects, function(collection) {\n        matchedObject = _.find(collection, function(anObject) {\n            return anObject.reference === objectRef;\n        });\n        return matchedObject;\n    });\n    return matchedObject;\n}\n\n/*\n * Returns the collection of objects for the specified type. Note that the type must be a root type\n */\nfunction getCollection(server, typeName) {\n    var schema = server._schemasByName[typeName];\n    if (!schema) {\n        dx.fail(typeName + ' is not a known type.');\n    }\n    if (schema.singleton) {\n        dx.fail(typeName + ' is a singleton type, not a collection type.');\n    }\n    var rootTypeName = getRootTypeForObject(schema, server._schemasByName);\n    if (!rootTypeName) {\n        dx.fail('Can only ask for collections with a root property.');\n    }\n    if (rootTypeName !== schema.name) {\n        dx.fail('Must specify the root type (' + rootTypeName + ').');\n    }\n\n    return server._objects[typeName] || [];\n}\n\n/*\n * Returns the specified singleton from the server\n */\nfunction getSingleton(server, typeName) {\n    if (!isSingleton(server, typeName)) {\n        dx.fail(typeName + ' is not a singleton type.');\n    }\n\n    if (!server._singletons[typeName]) {\n        server._singletons[typeName] = {\n            type: typeName\n        };\n    }\n\n    return server._singletons[typeName];\n}\n\nfunction isSingleton(server, typeName) {\n    var schema = server._schemasByName[typeName];\n    return schema && schema.singleton;\n}\n\n/*\n * Removes all the elements from the specified collection. No notifications are generated.\n */\nfunction clearCollection(server, typeName) {\n    var collection = getCollection(server, typeName);\n    collection.length = 0;\n}\n\nfunction getCollectionLength(server, typeName) {\n    var collection = getCollection(server, typeName);\n    return collection.length;\n}\n\n/*\n * Sets the 'standard (CRUD) object operations' that can be on the mock server.\n *\n * The parameter has the form discussed in the files header comment.\n *\n * You may override any of the standard operations that are supported for a given type. ServerCore already provides\n * default implementations of these handlers, but overriding these may be useful in certain cases, such as testing\n * various failure scenarious as well as being able to spy on these operations.\n * Any operations defined in the parameter will replace their equivalents already installed in the mock server, if any.\n */\nfunction addStandardOpHandlers(server, operationHash) {\n    if (!_.isObject(operationHash)) {\n        dx.fail('Expected an object, but got ' + JSON.stringify(operationHash) + '.');\n    }\n\n    _.each(operationHash, function(ops, type) {\n        _.each(ops, function(oFunc, oName) {\n            addStandardOpHandler(server, type, oName, oFunc);\n        });\n    });\n}\n\n/*\n * Like addStandardOpHandlers(), but instead adds a single operation.\n */\nfunction addStandardOpHandler(server, typeName, opName, opHandler) {\n    if (!_.isString(typeName)) {\n        dx.fail('Expected a string as a type name, but got ' + JSON.stringify(typeName) + '.');\n    }\n    if (!_.isString(opName)) {\n        dx.fail('Expected a string as an operation name, but got ' + JSON.stringify(opName) + '.');\n    }\n    if (!_.isFunction(opHandler)) {\n        dx.fail('Expected a function for the handler, but got ' + JSON.stringify(opHandler) + '.');\n    }\n    if (!server._schemasByName[typeName]) {\n        dx.fail(typeName + ' is not a schema type.');\n    }\n    if (!_.contains(STANDARD_OPERATONS, opName)) {\n        dx.fail(opName + ' is not one of the standard operations (' + STANDARD_OPERATONS.join(', ') + ').');\n    }\n    if (!server._schemasByName[typeName][opName]) {\n        dx.fail(opName + ' is not a standard operation on ' + typeName + '.');\n    }\n\n    server._customStdHandlers[typeName] = server._customStdHandlers[typeName] || {};\n    server._customStdHandlers[typeName][opName] = opHandler;\n}\n\n/*\n * Sets the 'root operations' that can be on the mock server.\n *\n * The parameter has the form discussed in the files header comment.\n */\nfunction addRootOpHandlers(server, operationHash) {\n    _.each(operationHash, function(ops, type) {\n        _.each(ops, function(oFunc, oName) {\n            addRootOpHandler(server, type, oName, oFunc);\n        });\n    });\n}\n\n/*\n * Like addRootOpHandlers(), but instead adds a single operation.\n */\nfunction addRootOpHandler(server, typeName, opName, opHandler) {\n    if (!_.isString(typeName)) {\n        dx.fail('Expected a string as a type name, but got ' + JSON.stringify(typeName) + '.');\n    }\n    if (!_.isString(opName)) {\n        dx.fail('Expected a string as an operation name, but got ' + JSON.stringify(opName) + '.');\n    }\n    if (!_.isFunction(opHandler)) {\n        dx.fail('Expected a function for the handler, but got ' + JSON.stringify(opHandler) + '.');\n    }\n    if (!server._schemasByName[typeName]) {\n        dx.fail(typeName + ' is not a schema type.');\n    }\n    if (!server._schemasByName[typeName].rootOperations || !server._schemasByName[typeName].rootOperations[opName]) {\n        dx.fail(opName + ' is not a root operation on ' + typeName + '.');\n    }\n\n    server._customRootHandlers[typeName] = server._customRootHandlers[typeName] || {};\n    server._customRootHandlers[typeName][opName] = opHandler;\n}\n\n/*\n * Adds one or more 'object operations' that can be on the mock server.\n *\n * The parameter has the form discussed in the files header comment.\n */\nfunction addObjectOpHandlers(server, operationHash) {\n    _.each(operationHash, function(ops, type) {\n        _.each(ops, function(oFunc, oName) {\n            addObjectOpHandler(server, type, oName, oFunc);\n        });\n    });\n}\n\n/*\n * Like addObjectOpHandlers(), but instead adds a single operation.\n */\nfunction addObjectOpHandler(server, typeName, opName, opHandler) {\n    if (!_.isString(typeName)) {\n        dx.fail('Expected a string as a type name, but got ' + JSON.stringify(typeName) + '.');\n    }\n    if (!_.isString(opName)) {\n        dx.fail('Expected a string as an operation name, but got ' + JSON.stringify(opName) + '.');\n    }\n    if (!_.isFunction(opHandler)) {\n        dx.fail('Expected a function for the handler, but got ' + JSON.stringify(opHandler) + '.');\n    }\n    if (!server._schemasByName[typeName]) {\n        dx.fail(typeName + ' is not a schema type.');\n    }\n    if (!server._schemasByName[typeName].operations || !server._schemasByName[typeName].operations[opName]) {\n        dx.fail(opName + ' is not an object operation on ' + typeName + '.');\n    }\n\n    server._customObjHandlers[typeName] = server._customObjHandlers[typeName] || {};\n    server._customObjHandlers[typeName][opName] = opHandler;\n}\n\n/*\n * Adds resources that can be called from a test.  In this case, a resource is an arbitrary string associated with\n * the full path portion of a URL.  This can be useful, for example, to register templates with the mock server that\n * can then be requested from a test.\n *\n * For example, this might be called with:\n * {\n *     '/test/template/basic.hjs': '<div id=basicTest></div>'\n * }\n */\nfunction addResources(server, resourcesHash) {\n    _.extend(server._resources, resourcesHash);\n}\n\nfunction HttpGet(server, url, payload) {\n    return HttpOperation(server, 'GET', url, payload);\n}\n\nfunction HttpPost(server, url, payload) {\n    return HttpOperation(server, 'POST', url, payload);\n}\n\nfunction HttpDelete(server, url, payload) {\n    return HttpOperation(server, 'DELETE', url, payload);\n}\n\nfunction HttpOperation(server, method, url, payloadOrParams) {\n    var result;\n    var path = method + ':' + url;\n\n    if (_.isString(payloadOrParams)) {\n        payloadOrParams = JSON.parse(payloadOrParams);\n    }\n\n    // Look at the URL and identify candidate handlers.\n    var objectOpMatch = OBJECT_OPERATION_REGX.exec(path);\n    var objectOpPath = objectOpMatch ? objectOpMatch[1] + INLINE_REF + objectOpMatch[3] : '';\n    var objectOpRef = objectOpMatch ? objectOpMatch[2] : '';\n    var objectOpHandler = server._builtinHandlers[objectOpPath];\n\n    var objectRUDMatch = OBJECT_READ_UPDATE_DELETE_REGEX.exec(path);\n    var objectRUDPath = objectRUDMatch[1] + TRAILING_REF;\n    var objectRUDRef = objectRUDMatch[2];\n    var objectRUDHandler = server._builtinHandlers[objectRUDPath];\n\n    if (objectOpHandler) {\n        result = objectOpHandler(objectOpRef, payloadOrParams, Result, server);\n    } else if (server._builtinHandlers[path]) {\n        result = server._builtinHandlers[path](payloadOrParams, Result, server);\n    } else if (objectRUDHandler) {\n        result = objectRUDHandler(objectRUDRef, payloadOrParams, Result, server);\n    } else if (server._resources[url] && method === 'GET') {\n        result = new Result(200, server._resources[url]);\n    } else {\n        result = new Result(server.UNKNOWN_URL_STATUS, null);\n    }\n\n    // If a handler returned a non-Result, assume it is an OkResult body, and return that instead\n    if (!(result instanceof Result)) {\n        result = new Result.OkResult(result || null);\n    }\n\n    return result;\n}\n\nfunction buildHandlersForSingletonSchema(server, schema) {\n    var singletoneType = schema.name;\n\n    if (schema.read) {\n        server._builtinHandlers['GET:' + schema.root] = function builtinSingleReadHandler(parameters, Result, server) {\n            var customHandlers = server._customStdHandlers[singletoneType];\n            if (customHandlers && customHandlers.read) {\n                return customHandlers.read(parameters, Result, server) || new Result.OkResult({});\n            }\n\n            return new Result.OkResult(getSingleton(server, singletoneType));\n        };\n    }\n\n    /*\n     * Singletons can have only an update or a create, but not both (there is no reference property to distinguish them\n     * as there is with ordinary objects)\n     */\n    if (schema.update || schema.create) {\n        server._builtinHandlers['POST:' + schema.root] = function builtinSingleUpdateCreate(payload, Result, server) {\n            var customHandlers = server._customStdHandlers[singletoneType];\n\n            payload = deepClone(payload) || {};\n            payload.type = singletoneType;\n\n            if (schema.create) {\n                if (customHandlers && customHandlers.create) {\n                    return customHandlers.create(payload, Result, server);\n                }\n\n                createObject(server, payload);\n            } else {\n                if (customHandlers && customHandlers.update) {\n                    return customHandlers.update(payload, Result, server);\n                }\n\n                updateObject(server, payload);\n            }\n\n            return new Result.OkResult(null);\n        };\n    }\n\n    buildRootOperationHandlers(server, schema);\n}\n\nfunction buildHandlersForCollectionSchema(server, schema) {\n    buildStandardOperationHandlers(server, schema);\n    buildRootOperationHandlers(server, schema);\n    buildOperationHandlers(server, schema);\n}\n\nfunction buildStandardOperationHandlers(server, schema) {\n    var methodAndUrl;\n    var typeName = schema.name;\n\n    if (schema.list) {\n        methodAndUrl = 'GET:' + schema.root;\n\n        server._builtinHandlers[methodAndUrl] = function builtinListHandler(parameters, Result, server) {\n            var customHandlers = server._customStdHandlers[typeName];\n\n            if (customHandlers && customHandlers.list) {\n                var result = customHandlers.list(parameters, Result, server);\n\n                // Special case. If the handler returned nothing or a non-result, return a ListResult\n                result = result || [];\n                if (!(result instanceof Result)) {\n                    return new Result.ListResult(result);\n                }\n\n                return result;\n            }\n\n            var collection = getCollection(server, typeName);\n\n            if (server._filters[typeName]) {\n                collection = server._filters[typeName](collection, parameters || {}, typeName, server._schemasByName);\n            }\n\n            return new Result.ListResult(collection);\n        };\n    }\n\n    if (schema.create) {\n        methodAndUrl = 'POST:' + schema.root;\n\n        server._builtinHandlers['POST:' + schema.root] = function builtinCreateHandler(payload, Result, server) {\n            var customHandlers = server._customStdHandlers[typeName];\n            var targetType = typeName;\n            var payloadSchema;\n            var rootTypeName;\n\n            if (customHandlers && customHandlers.create) {\n                return customHandlers.create(payload, Result, server);\n            }\n\n            if (payload && payload.type) {\n                targetType = payload.type;\n            }\n            payloadSchema = server._schemasByName[targetType];\n            if (!payloadSchema) {\n                dx.fail(targetType + ' is not a known schema type.');\n            }\n            rootTypeName = getRootTypeForObject(payloadSchema, server._schemasByName);\n            if (rootTypeName !== typeName) {\n                dx.fail('Trying to create a ' + typeName + ' but received a payload of type ' + payload.type +\n                    '. Use addStandardOpHandlers() to roll your own create logic.');\n            }\n\n            var objectsToCreate = {};\n            objectsToCreate[typeName] = [payload];\n\n            var references = createObjects(server, objectsToCreate);\n\n            return new Result.OkResult(references[0]);\n        };\n    }\n\n    if (schema.read) {\n        methodAndUrl = 'GET:' + schema.root + TRAILING_REF;\n\n        server._builtinHandlers[methodAndUrl] = function builtinReadHandler(reference, payload, Result, server) {\n            var customHandlers = server._customStdHandlers[typeName];\n            if (customHandlers && customHandlers.read) {\n                return customHandlers.read(reference, payload, Result, server) || new Result.OkResult({});\n            }\n\n            var obj = getObject(server, reference, typeName);\n            if (!obj) {\n                return new Result.MissingObjResult(typeName, reference, 'read');\n            }\n\n            return new Result.OkResult(obj);\n        };\n    }\n\n    if (schema.update) {\n        methodAndUrl = 'POST:' + schema.root + TRAILING_REF;\n        server._builtinHandlers[methodAndUrl] = function builtinUpdateHandler(reference, payload, Result, server) {\n            var customHandlers = server._customStdHandlers[typeName];\n            if (customHandlers && customHandlers.update) {\n                return customHandlers.update(reference, payload, Result, server);\n            }\n\n            if (!getObject(server, reference, typeName)) {\n                return new Result.MissingObjResult(typeName, reference, 'update');\n            }\n\n            // 'reference' is inferred by the url and must not be part of the data already.\n            payload = deepClone(payload);\n            payload.reference = reference;\n\n            updateObjects(server, [payload]);\n\n            return new Result.OkResult(null);\n        };\n    }\n\n    if (schema.delete) {\n        methodAndUrl = 'DELETE:' + schema.root + TRAILING_REF;\n\n        server._builtinHandlers[methodAndUrl] = function builtinDeleteHandler(reference, payload, Result, server) {\n            var customHandlers = server._customStdHandlers[typeName];\n            if (customHandlers && customHandlers.delete) {\n                return customHandlers.delete(reference, payload, Result, server);\n            }\n\n            if (!getObject(server, reference, typeName)) {\n                return new Result.MissingObjResult(typeName, reference, 'delete');\n            }\n\n            deleteObjects(server, [reference]);\n\n            return new Result.OkResult(null);\n        };\n    }\n}\n\nfunction buildOperationHandlers(server, schema) {\n    _.each(schema.operations, function(opDef, operationName) {\n        var httpMethod = opDef.payload ? 'POST' : 'GET';\n        var methodAndUrl = httpMethod + ':' + schema.root + INLINE_REF + operationName;\n\n        server._builtinHandlers[methodAndUrl] = function builtinObjHandler(objectRef, payloadOrParams, Result, server) {\n            if (!getObject(server, objectRef, schema.name)) {\n                return new Result.MissingObjResult(schema.name, objectRef, operationName);\n            }\n\n            var customHandlers = server._customObjHandlers[schema.name];\n            if (customHandlers && customHandlers[operationName]) {\n                return customHandlers[operationName](objectRef, payloadOrParams, Result, server);\n            }\n\n            dx.fail('Test called ' + schema.name + '.' + operationName + ', but no handler registered for it.');\n        };\n    });\n}\n\nfunction buildRootOperationHandlers(server, schema) {\n    _.each(schema.rootOperations, function(opDef, operationName) {\n        var httpMethod = opDef.payload ? 'POST' : 'GET';\n        var methodAndUrl = httpMethod + ':' + schema.root + '/' + operationName;\n\n        server._builtinHandlers[methodAndUrl] = function builtinRootOpHandler(payloadOrParams, Result, server) {\n            var customHandlers = server._customRootHandlers[schema.name];\n            if (customHandlers && customHandlers[operationName]) {\n                return customHandlers[operationName](payloadOrParams, Result, server);\n            }\n\n            dx.fail('Test called ' + schema.name + '.' + operationName + ', but no handler registered for it.');\n        };\n    });\n}\n\nfunction Result(statusCode, data) {\n    var self = this;\n\n    if (!(self instanceof Result)) {\n        dx.fail('Must call Result() with new.');\n    }\n\n    self.statusCode = statusCode;\n    self.data = data;\n}\n\nfunction OkResult(data) {\n    if (!(this instanceof OkResult)) {\n        dx.fail('Must call Result.OkResult() with new.');\n    }\n\n    return new Result(200, {\n        type: 'OKResult',\n        result: data\n    });\n}\n\nfunction ListResult(data) {\n    if (!_.isArray(data)) {\n        dx.fail('Must call Result.ListResult() with an array.');\n    }\n    if (!(this instanceof ListResult)) {\n        dx.fail('Must call Result.ListResult() with new.');\n    }\n\n    return new Result(200, {\n        type: 'ListResult',\n        result: data\n    });\n}\n\nfunction ErrorResult(statusCode, error) {\n    if (!(this instanceof ErrorResult)) {\n        dx.fail('Must call Result.ErrorResult() with new.');\n    }\n\n    return new Result(statusCode, {\n        type: 'ErrorResult',\n        status: 'ERROR',\n        error: error\n    });\n}\n\nfunction MissingObjResult(type, ref, operation) {\n    if (!(this instanceof MissingObjResult)) {\n        dx.fail('Must call Result.MissingObjResult() with new.');\n    }\n\n    return new ErrorResult(404, {\n        type: 'APIError',\n        details: type + '/' + ref + ' could not be found for ' + operation + '.',\n        id: 'object.missing'\n    });\n}\n\n_.extend(Result, {\n    OkResult: OkResult,\n    ListResult: ListResult,\n    ErrorResult: ErrorResult,\n    MissingObjResult: MissingObjResult\n});\n\n// Returns the property definition if instances of the specified schema have a specific property, undefined otherwise\nfunction getPropDef(schema, propName, schemasByName) {\n    if (schema.properties && schema.properties[propName]) {\n        return schema.properties[propName];\n    }\n\n    if (schema.extends && schema.extends.$ref) {\n        return getPropDef(schemasByName[schema.extends.$ref], propName, schemasByName);\n    }\n}\n\n// Returns the name of the root type for the specified schema, or undefined.\nfunction getRootTypeForObject(schema, schemasByName) {\n    if (schema.root) {\n        return schema.name;\n    }\n\n    if (schema.extends && schema.extends.$ref) {\n        return getRootTypeForObject(schemasByName[schema.extends.$ref], schemasByName);\n    }\n}\n\nfunction processSchemas(server, schemas) {\n    function fixName(schemaKey) {\n        return schemaKey.replace(/\\.json$/, '')\n            .replace(/-/g, '_')\n            .replace(/\\//g, '');\n    }\n\n    // Fix all the names for all the schemas, and store them by name\n    _.each(schemas, function(schema, schemaKey) {\n        // don't modify the original schema\n        var schemaCopy = deepClone(schema);\n        if (!schemaCopy.name) {\n            schemaCopy.name = fixName(schemaKey);\n        }\n        server._schemasByName[schemaCopy.name] = schemaCopy;\n    });\n\n    // Fix internal references to the schemas and build the callback handlers for all operations.\n    _.each(server._schemasByName, function(schema) {\n        if (schema.extends) {\n            schema.extends.$ref = fixName(schemas[schema.extends.$ref].name);\n        }\n\n        if (schema.root) {\n            if (schema.singleton) {\n                buildHandlersForSingletonSchema(server, schema);\n            } else {\n                buildHandlersForCollectionSchema(server, schema);\n            }\n        }\n    });\n}\n\n/*\n * Does a deep clone of the specified object, but replaces Date instances with .toJSON() equivalents, and\n * undefined with null.\n */\nfunction deepClone(obj) {\n    var result = obj;\n\n    if (_.isArray(obj)) {\n        result = [];\n        for (var index = 0; index < obj.length; index++) {\n            result[index] = deepClone(obj[index]);\n        }\n    } else if (_.isObject(obj)) {\n        if (_.isDate(obj)) {\n            result = obj.toJSON();\n        } else {\n            result = {};\n            _.each(obj, function(value, index) {\n                if (_.isUndefined(value)) {\n                    value = null;\n                }\n                result[index] = deepClone(value);\n            });\n        }\n    }\n\n    return result;\n}\n\n/*\n * Return a function that does a deep clone of the return value\n */\nfunction deepCloneReturn(func, server) {\n    return function() {\n        // All our functions take the server as their first argument.\n        Array.prototype.unshift.call(arguments, server);\n        return deepClone(func.apply(server, arguments));\n    };\n}\n\nfunction reset(server) {\n    server._singletons = {};\n    server._objects = {};\n    server._nextReference = START_REF;\n    server._resources = {};\n    server._customObjHandlers = {};   // { type: { op: function() } }\n    server._customRootHandlers = {};\n    server._customStdHandlers = {};\n}\n\n/*\n * Document structure of schemas\n */\nfunction ServerCore(schemas) {\n    var self = this;\n    if (!(self instanceof ServerCore)) {\n        dx.fail('Must call ServerCore() with new.');\n    }\n    if (!schemas) {\n        dx.fail('Must pass a map of schemas when constructing a ServerCore.');\n    }\n\n    self._schemasByName = {};\n    self._builtinHandlers = {}; // 'HTTPMMETHOD:url': function()\n    self._filters = [];\n    reset(self);\n\n    processSchemas(this, schemas);\n\n    _.extend(self, {\n        UNKNOWN_URL_STATUS: 1000,\n        createObjects: _.partial(createObjects, self),\n        updateObjects: _.partial(updateObjects, self),\n        deleteObjects: _.partial(deleteObjects, self),\n        getObject: deepCloneReturn(getObject, self),\n        getSingleton: deepCloneReturn(getSingleton, self),\n        getCollection: deepCloneReturn(getCollection, self),\n        clearCollection: _.partial(clearCollection, self),\n        getCollectionLength: _.partial(getCollectionLength, self),\n        addStandardOpHandlers: _.partial(addStandardOpHandlers, self),\n        addStandardOpHandler: _.partial(addStandardOpHandler, self),\n        addRootOpHandlers: _.partial(addRootOpHandlers, self),\n        addRootOpHandler: _.partial(addRootOpHandler, self),\n        addObjectOpHandlers: _.partial(addObjectOpHandlers, self),\n        addObjectOpHandler: _.partial(addObjectOpHandler, self),\n        addResources: _.partial(addResources, self),\n        GET: deepCloneReturn(HttpGet, self),\n        POST: deepCloneReturn(HttpPost, self),\n        DELETE: deepCloneReturn(HttpDelete, self),\n        reset: _.partial(reset, self)\n    });\n}\n\ndx.test.ServerCore = ServerCore;\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _ */\n\n'use strict';\n\ndx.namespace('dx.test._filters');\n\n/*\n * Defines a set of filter helper functions for delphix schema root types to be used by the Mock Server.\n * New filters should be added here, with each filter named by the root type.\n *\n * mockCollectionFilters differ from level2-filters in a number of ways:\n * 1. These are synchronous, as the mockServer is written synchronously. level2-filters are async.\n * 2. These deal with plain objects, while level2-filters must deal with Backbone models.\n * 3. These have a global view of the objects in the system, and can thus deal with things like paging, whereas\n *    level2-filters can not.\n *\n * Many filters can be autogenerated from the schemas and schema annotations defined in level1-schema.js. These use the\n * uberFilter. However, there are still some types which cannot be autogenerated due to complex logic which cannot be\n * inferred from the schema.\n *\n * Each filter function takes in a collection and a hash of query parameters, and will return the filtered version of\n * the collection.\n *\n * Note: These filters should be kept in sync with level2-filters.\n */\n(function() {\n\nvar DATE_PROPS = ['fromDate', 'startDate', 'toDate', 'endDate'];\n\nfunction missingObject(type, reference) {\n    dx.fail('The ' + type + ' (' + reference + ') does not exist in the mock server and is needed to filter your ' +\n            '$$list operation.');\n}\n\n// Parse the 'mapsTo' property for the query parameter and follow the data mapping chain\nfunction followDataMapping(object, mapsTo, parsedSchemas) {\n    var parts = mapsTo.split('.');\n\n    // We know the last part will be property to compare. Anything before that will be a chain of object dereferencing\n    var finalAttrName = parts.pop();\n\n    var currObj = object;\n    _.each(parts, function(part) {\n        var type = parsedSchemas[currObj.type].properties[part].referenceTo;\n\n        var newObj = dx.test.mockServer.getObject(currObj[part], type);\n        if (!newObj) {\n            missingObject(type, currObj[part]);\n        }\n\n        currObj = newObj;\n    });\n\n    return { object: currObj, attrName: finalAttrName };\n}\n\n/*\n * Helper for a single query parameter. Will follow a data mapping and check that the qParam value matches the object's\n * property value.\n */\nfunction checkSimpleProp(qParamVal, qParamName, objectSchema, object, parsedSchemas) {\n    var mapsTo = objectSchema.list.parameters[qParamName].mapsTo;\n    if (!mapsTo) {\n        dx.fail('No mapsTo property found for query parameter ' + qParamName + '.');\n    }\n\n    var pair = followDataMapping(object, mapsTo, parsedSchemas);\n    var finalObj = pair.object;\n    var finalAttrName = pair.attrName;\n\n    return qParamVal === finalObj[finalAttrName];\n}\n\n/*\n * Helper for a single query parameter. Will follow a data mapping and check a date-related query parameter.\n */\nfunction checkDateProp(qParamVal, qParamName, objectSchema, object, parsedSchemas) {\n    var mapsTo = objectSchema.list.parameters[qParamName].mapsTo;\n    if (!mapsTo) {\n        dx.fail('No mapsTo property found for query parameter ' + qParamName);\n    }\n\n    if (!_.contains(DATE_PROPS, qParamName)) {\n        dx.fail('Expected a date related query parameter (' + DATE_PROPS.join(', ') + ') but found: ' + qParamName);\n    }\n\n    var inequalityType = objectSchema.list.parameters[qParamName].inequalityType;\n\n    if (_.isUndefined(inequalityType)) {\n        dx.fail('Date property \"' + qParamName + '\" missing \"inequalityType\" schema property');\n    }\n\n    var pair = followDataMapping(object, mapsTo, parsedSchemas);\n    var finalObj = pair.object;\n    var finalAttrName = pair.attrName;\n\n    // Since we are at the mockServer level, the query parameters passed in may be timestamps, not Date objects\n    if (!_.isDate(qParamVal)) {\n        qParamVal = new Date(qParamVal);\n    }\n\n    // Handle the case where this is a timestamp string as well as a Date object\n    var objAttrVal = finalObj[finalAttrName];\n    if (_.isString(objAttrVal)) {\n        objAttrVal = new Date(objAttrVal);\n    }\n\n    if (dx.core.util.isNone(objAttrVal)) {\n        return false;\n    }\n\n    if (_.contains(['fromDate', 'startDate'], qParamName)) {\n        if (objAttrVal.getTime() < qParamVal.getTime()) {\n            return false;\n        }\n    } else if (objAttrVal.getTime() > qParamVal.getTime()) { // toDate or endDate\n        return false;\n    }\n\n    if (inequalityType === dx.core.constants.INEQUALITY_TYPES.STRICT && objAttrVal.getTime() === qParamVal.getTime()) {\n        return false;\n    }\n\n    return true;\n}\n\n/*\n * Helper to determine if a mock server object should be included given it's index and paging parameters.\n * Note that this assumes not specifying a page size implicitly sets it to a particular size (generally 25),\n * while specifying 0 means 'all'.\n */\nfunction checkPageSize(qParams, objectIndex, collectionLength) {\n    var start, end, pageSize, pageOffset;\n\n    if (qParams.pageSize === 0) {\n        return true;\n    }\n\n    pageSize = qParams.pageSize || 25;\n    pageOffset = qParams.pageOffset || 0; // No pageOffset gives you the page with the most recent data\n\n    if (pageSize < 0) {\n        dx.fail('pageSize must be a positive integer');\n    }\n\n    if (pageOffset >= 0) {\n        end = collectionLength - pageSize * pageOffset - 1;\n        start = Math.max(0, end - pageSize + 1);\n    } else {\n        // Negative offset takes the page from the older end of the collection, with -1 being the oldest\n        start = pageSize * -(pageOffset + 1);\n        end = Math.min(collectionLength - 1, start + pageSize - 1);\n    }\n\n    return objectIndex >= start && objectIndex <= end;\n}\n\n/*\n * Check an array of query parameters against an object.\n */\nfunction checkProps(qParamNamesToCheck, qParams, object, objectSchema, parsedSchemas) {\n    return _.every(qParamNamesToCheck, function(qParamName) {\n        if (!_.has(qParams, qParamName)) {\n            return true;\n        }\n\n        var dateParams = ['fromDate', 'startDate', 'toDate', 'endDate'];\n        var qParamVal = qParams[qParamName];\n\n        if (_.contains(dateParams, qParamName)) {\n            return checkDateProp(qParamVal, qParamName, objectSchema, object, parsedSchemas);\n        } else {\n            return checkSimpleProp(qParamVal, qParamName, objectSchema, object, parsedSchemas);\n        }\n    });\n}\n\n/*\n * One filter to rule them all, one filter to find them,\n * One filter to bring them all and in the darkness bind them.\n *\n * In the days of old there were many filters freely roaming the land. At the end of the second age, schema annotations\n * were introduced into level1-schemas.js. This gave the dark lord all the tools he needed to corral the filters into a\n * single uberFilter, thus beginning a period of darkness and code maintainability. However, a few misfit filters\n * managed to escape the all seeing gaze of the dark lord, their logic simply too complex to be handled by the\n * uberFilter.\n */\nfunction uberFilter(collection, qParams, collectionType, parsedSchemas) {\n    parsedSchemas = parsedSchemas || dx.core.data.parsedSchemas;\n    var objectSchema = parsedSchemas[collectionType];\n\n    return _.filter(collection, function(object) {\n        return checkProps(_.keys(qParams), qParams, object, objectSchema, parsedSchemas);\n    });\n}\n\n/*\n * uberFilter needs the type to get schema information. This wraps uberFilter and returns a function that conforms to\n * the signature expected by mockServer.\n */\nfunction makeUberFilter(type) {\n    return function wrappedUberFilter(collection, qParams) {\n        return uberFilter(collection, qParams, type);\n    };\n}\n\n/*\n * Wraps an individual filter function to take care of logic around paging.\n */\nfunction maybeAddPagingToFilter(type, filterFunc, context) {\n    var ctx = context || dx.core.data;\n    var supportsPaging = 'pageSize' in ctx.parsedSchemas[type].list.parameters;\n\n    return function wrappedFilter(collection, qParams) {\n        var pagingParams,\n            result = collection;\n\n        // Separate paging parameters from other parameters\n        pagingParams = _.pick(qParams, 'pageSize', 'pageOffset');\n        qParams = _.omit(qParams, 'pageSize', 'pageOffset');\n\n        result = filterFunc(collection, qParams);\n\n        if (supportsPaging) {\n            result = _.filter(result, function(object, index) {\n                return checkPageSize(pagingParams, index, result.length);\n            });\n            // The most recent result should be the first (index 0) in the list\n            result.reverse();\n        }\n\n        return result;\n    };\n}\n\n_.extend(dx.test._filters, {\n    _uberFilter: uberFilter,\n    makeUberFilter: makeUberFilter,\n    missingObject: missingObject,\n    checkProps: checkProps,\n    maybeAddPagingToFilter: maybeAddPagingToFilter\n});\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _ */\n\n'use strict';\n\ndx.namespace('dx.test');\n\n/*\n * Defines a MockServer which responds to ajax calls, and then stores results until a caller/test calls respond().\n * This allows tests to make use of asynchronous behavior without actually creating asynchronous tests.\n *\n * An example use is:\n *\n *    it('does something wonderful', function() {\n *        var mockServer = new dx.test.MockServer(MY_SCHEMAS);\n *        mockServer.start();\n *\n *        var promise = dx.core.data.getServerModelPromise('CONTAINER-1', 'Container');\n *        promise.then(function() {});\n *\n *        // Note that this has \"sent\" an \"asynchronous\" request to the MockServer\n *        dx.test.assert(promise).not.toHaveBeenCalled();\n *\n *        mockServer.respond(); // Tell the server to deliver the \"asynchronous\" results to the client\n *\n *        expect(resultSpy).toHaveBeenCalled();\n *    });\n *\n * Note that this MockServer is a ServerCore instance, so all the functions on ServerCore to add, update etc. are here\n * as well.\n *\n * It is notable that the respond() function can take a function with the following signature:\n *     respondFilter(response, stash)\n * response is a Response object which has these interesting properties:\n *    index     The number (starting at 1) of the response during the current respond() call\n *    getData() Returns the data to be returned to the client\n *    deliver() Tells the mock server to deliver this response to the client\n *    stash()   Tells the mock server to store this response for future handling (see \"stash\", below)\n *    delay(ms) Tells the mock server to deliver this response after \"ms\" milliseconds (caller must still call respond)\n * stash is an object that contains any responses that have been previously stash()'ed during this test. You can:\n *    getSize()    Returns how many responses are in the stash\n *    deliverAll() Have all the responses in the stash returned to the client\n *\n * Note that if a respondFilter is provided, if there are no already-existing responses waiting to be delivered, and\n * there are items in the stash, the responseFilter will be called with the response object set to undefined.  This\n * allows you to have the opportunity to work with the stash despite the absence of pending responses.\n */\n(function() {\n\n/*\n * Response is the \"public interface\" to results that is given to respond() callers that pass in a filter function.\n * This provides functions for all the things that can be done with the result. It does rely on intimate access to\n * the mock server's internals.\n */\nfunction Response(result, resultCount, server) {\n    var self = this;\n    self._result = result;\n    self._server = server;\n    self._delivered = false;\n    self._handled = undefined;\n    self.index = resultCount;\n}\n\nfunction getData() {\n    var self = this;\n    return self._result.data;\n}\n\nfunction deliver() {\n    var self = this;\n    self._assertNotHandled();\n\n    self._delivered = true;\n    self._handled = 'delivered';\n    self._server._deliverResult(self._result);\n}\n\nfunction delay(milliseconds) {\n    var self = this;\n    self._assertNotHandled();\n\n    self._handled = 'delayed';\n    self._server._timeoutResults.push(self._result);\n    self._server._timeoutIds.push(setTimeout(delayedDelivery.bind(self), milliseconds));\n}\n\nfunction stash() {\n    var self = this;\n    self._assertNotHandled();\n\n    self._handled = 'stashed';\n    self._server._stash._addResult(self._result);\n}\n\nfunction delayedDelivery() {\n    var self = this;\n    var index = self._server._timeoutResults.indexOf(self._result);\n\n    self._server._timeoutResults.splice(index, 1);\n    handleResult(self._server, self._result);\n}\n\nfunction assertNotHandled() {\n    var self = this;\n    if (self._handled) {\n        dx.fail('Already ' + self._handled + ' this response.');\n    }\n}\n\n_.extend(Response.prototype, {\n    _assertNotHandled: assertNotHandled,\n    getData: getData,\n    deliver: deliver,\n    delay: delay,\n    stash: stash\n});\n\n/*\n * A Stash is a collection of results that a respond() filter function has decided it doesn't want to have delivered\n * yet.  It persists across respond() calls, but its contents are delivered to the client when the server is reset.\n */\nfunction Stash(server) {\n    var self = this;\n    self._stash = [];\n    self._server = server;\n}\n\nfunction getSize() {\n    var self = this;\n    return self._stash.length;\n}\n\nfunction addResult(result) {\n    var self = this;\n    self._stash.push(result);\n}\n\nfunction deliverAll() {\n    var self = this;\n    var stashCopy = self._stash;\n    self._stash = [];\n    _.each(stashCopy, function(item) {\n        self._server._deliverResult(item);\n    });\n    $.event.trigger('ajaxComplete');\n}\n\n_.extend(Stash.prototype, {\n    _addResult: addResult,\n    getSize: getSize,\n    deliverAll: deliverAll\n});\n\nfunction handleUnknownUrl(server, method, url, settings) {\n    /*\n     * An unknown URL via a GET is not that uncommon. Some i18n libraries routinely ask for things that don't\n     * exit. In these cases, we just want to give them a 404.\n     */\n    if (method === 'GET') {\n        server._handleResult(server._addToResult({ statusCode: 404 }, settings, server._ajaxCallId));\n        return;\n    }\n    /*\n     * Logically, this is a 404 situation.  But, also in theory this really shouldn't ever happen.  A thrown error\n     * makes it clearer that the developer has done something very un-ok.\n     */\n    dx.fail('The requested resource is not available: ' + method + ':' + url);\n}\n\n/*\n * Unless the request was a sync one, the MockServer merely queues results until respond() is called.\n */\nfunction handleResult(server, result) {\n    server._reportDebug(result.callId, 'Result: Status ' + result.statusCode, result.data);\n\n    if (result.async === false) {\n        server._deliverResult(result);\n    } else {\n        server._pendingResults.push(result);\n    }\n}\n\n/*\n * Deliver any queued results.  If a filter function is provided, give it the results first to decide if they should\n * be returned.\n */\nfunction respond(server, filterFunction) {\n    if (!_.isUndefined(filterFunction) && !_.isFunction(filterFunction)) {\n        dx.fail('Filter function, if provided, must be a function.');\n    }\n    var resultCount = 0;\n    var resultSent;\n\n    server._processNotifications();\n\n    if (filterFunction && server._pendingResults.length === 0 && server._stash.getSize() > 0) {\n        filterFunction(undefined, server._stash);\n    }\n\n    while (server._pendingResults.length > 0) {\n        var result = server._pendingResults.shift();\n        resultCount++;\n\n        if (filterFunction) {\n            var response = new Response(result, resultCount, server);\n            filterFunction(response, server._stash);\n            resultSent = response._delivered;\n            if (!response._handled) {\n                dx.fail('Must do something with the response.');\n            }\n        } else {\n            resultSent = true;\n            server._deliverResult(result);\n        }\n\n        // Check if there are any notifications which should be returned.\n        server._processNotifications();\n    }\n\n    /*\n     * notify the system that an ajax call returned. Technically this should be done on every callback, but that drags\n     * down our test performance considerably, and doing it once per respond() seems sufficient.\n     */\n    if (resultSent) {\n        $.event.trigger('ajaxComplete');\n    }\n}\n\n/*\n * This forces a thorough respond, which means any pending longpolls are responded to (with an empty array if\n * necessary), any stashed values are returned, any values waiting for timeouts are also returned.  This was designed\n * to be used in test cleanup to make sure the server is done with any necesary work.\n */\nfunction forceRespond(server) {\n    /*\n     * If a reset is being done while notification system is active, we want to allow a new longpoll to come in while\n     * we are resetting.\n     */\n    var pendingLongpolls = server._pendingLongpolls.slice(0);\n    server._pendingLongpolls = [];\n    _.each(pendingLongpolls, function(result) {\n        server._deliverResult(_.extend(result, {\n            statusCode: 200,\n            data: {\n                type: 'ListResult',\n                result: []\n            }\n        }));\n    });\n    _.each(server._timeoutResults, server._deliverResult);\n    _.each(server._timeoutIds, clearTimeout);\n    server._stash.deliverAll();\n    server.respond();\n\n    server._pendingResults = [];\n    server._timeoutIds = [];\n    server._timeoutResults = [];\n    server._ajaxCallId = 0;\n}\n\nfunction MockServer(schemas) {\n    var self = this;\n    if (!(self instanceof MockServer)) {\n        dx.fail('Must call MockServer() with new.');\n    }\n    if (!_.isObject(schemas)) {\n        dx.fail('Must pass a map of schemas when constructing a server.');\n    }\n\n    var server = new dx.test.AbstractServer(schemas);\n    var serverReset = server.reset;\n\n    _.extend(server, {\n        _pendingResults: [],\n        _timeoutIds: [],\n        _timeoutResults: [],\n        _stash: new Stash(server),\n        _forceRespond: _.partial(forceRespond, server),\n        _handleUnknownUrl: _.partial(handleUnknownUrl, server),\n        _handleResult: _.partial(handleResult, server),\n        respond: _.partial(respond, server),\n        reset: function() {\n            serverReset.apply(server);\n            server._forceRespond();\n        }\n    });\n\n    return server;\n}\n\ndx.test.MockServer = MockServer;\n})();\n"
  ]
}