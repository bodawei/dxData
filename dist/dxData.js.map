{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/dxBasics.js",
    "src/layer1/js/schema.js",
    "src/layer2/js/cache.js",
    "src/layer2/js/collection.js",
    "src/layer2/js/creationListener.js",
    "src/layer2/js/filter.js",
    "src/layer2/js/model.js",
    "src/layer3/js/api.js",
    "src/layer3/js/notification.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC12DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2013, 2014 by Delphix. All rights reserved.\n */\n\n/*global _, dx */\n\n'use strict';\n\n/*\n * Misc \"common code\" needed by the dxData code\n */\n(function() {\n\n/*\n * Delphix framework/top-level namespace\n */\nwindow.dx = window.dx || {\n    namespace: function(namespace) {\n        var current = window;\n        _.each(namespace.split('.'), function(pName) {\n            current = (current[pName] = current[pName] || {});\n        });\n        return current;\n    },\n \n    /*\n     * Report a failing message. Writes the info to the console and throws an error\n     */\n    fail: function() {\n        window.console.error.call(window.console, arguments);\n        throw new Error(arguments[0]);\n    },\n \n    /*\n     * Report a warning message. Writes the info to the console\n     */\n    warn: function() {\n        window.console.warn.call(window.console, arguments);\n    },\n\n    /*\n     * Report an info message. Writes the info to the console\n     */\n    info: function() {\n        window.console.info.call(window.console, arguments);\n    },\n\n    /*\n     * Report an debug message. Writes the info to the console\n     */\n    debug: function() {\n        window.console.info.call(window.console, arguments);\n    },\n\n    /*\n     * Dummy stub for a localization system\n     */\n    gls: function(message) {\n        return '[' + message + ']';\n    }\n};\n\n/*\n * Constants\n */\ndx.namespace('dx.core.constants');\n\ndx.core.constants = {\n    INEQUALITY_TYPES: {\n        STRICT: 'STRICT',\n        NON_STRICT: 'NON-STRICT'\n    },\n    LIST_TYPES: {\n        NONE:   'NONE',\n        UBER:   'UBER',\n        CUSTOM: 'CUSTOM'\n    }\n};\n\n/*\n * General utilities\n */\ndx.namespace('dx.core.util');\n\ndx.core.util = {\n    /*\n     * Short cut for checking if a value is either null or undefined\n     */\n    isNone: function(value) {\n        return _.isNull(value) || _.isUndefined(value);\n    },\n \n    /*\n     * Stub for reloading the client in the case we've been told by the server we are out of sync\n     */\n    reloadClient: function() {\n    },\n\n    /*\n     * Returns a new object that is a deep clone of the input object.\n     */\n    deepClone: function(obj) {\n        var result = obj;\n\n        if (_.isArray(obj)) {\n            result = [];\n            _.each(obj, function(value, index) {\n                result[index] = dx.core.util.deepClone(value);\n            });\n        } else if (_.isObject(obj)) {\n            if (obj instanceof Date) {\n                result = new Date(obj.getTime());\n            } else {\n                result = {};\n                _.each(obj, function(value, index) {\n                    result[index] = dx.core.util.deepClone(value);\n                });\n            }\n        }\n\n        return result;\n    }\n\n};\n\n/*\n * Ajax utility routines\n */\ndx.namespace('dx.core.ajax');\n\n/*\n * Wrapper function for jquery $.ajax function\n *    config - $.ajax configuration object.\n */\ndx.core.ajax = {\n    /*\n     * We support the ability to replace what function is actually performing the\n     * necessary ajax calls.  This is only useful, in practice, for the mock servers\n     * so they can intercept outgoing calls and respond to them. We allow for multiple\n     * mock servers to be installed simultaneously, however only one can respond to\n     * a particular request, and the most recent server that took over the calls\n     * wins. in this regard, handlers act like a stack. However, any server can\n     * remove itself from the stack at any time, even if it isn't the topmost.\n     */\n    _handlers: [],\n    _baseHandlerForReset: {\n        owner: 'dx.baseHandler',\n        handler: function (config) {\n            return $.ajax(config);\n        }\n    },\n    // Used by the ApiServer to be able to bypass any ajax handlers set in place\n    getAjaxBaseHandler: function (owner) {\n        return this._handlers[0];\n    },\n    // Allows one to replace the default base handler\n    setAjaxBaseHandler: function (owner, handler) {\n        this._baseHandlerForReset = {\n            owner,\n            handler\n        };\n        this._handlers[0] = this._baseHandlerForReset;\n    },\n    hasAjaxHandler: function (owner) {\n        var topIndex = this._handlers.length - 1;\n\n        for (let index = topIndex; index > 0; index --) {\n            var item = this._handlers[index];\n\n            if (item.owner === owner) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n    registerAjaxHandler: function(owner, handler) {\n        this._handlers.push({\n            owner: owner,\n            handler: handler\n        });\n    },\n    removeAjaxHandler: function(owner) {\n        var topIndex = this._handlers.length - 1;\n\n        for (let index = topIndex; index > 0; index --) {\n            var item = this._handlers[index];\n\n            if (item.owner === owner) {\n                this._handlers.splice(index , 1);\n                return;\n            }\n        }\n\n        throw new Error('That handler has not been registered.')\n    },\n    resetAjaxHandlers: function () {\n        this._handlers = [this._baseHandlerForReset];\n    },\n    // This is the main entrypoint to making ajax calls.  It will use\n    // the topmost handler to actually do the call.\n    ajaxCall: function(config) {\n        if (config && config.url) {\n            config.type = config.type || 'GET';\n            config.contentType = config.contentType || 'application/json';\n            config.dataType = config.dataType || 'json';\n\n            config.xhrFields = config.xhrFields || {\n                withCredentials: true\n            };\n\n            config.success = config.success || function(d) {\n                dx.debug(d);\n            };\n\n            config.error = config.error || function(e) {\n                dx.debug(e);\n            };\n\n            config.cache = config.cache || false;\n\n            try {\n                var topIndex = this._handlers.length - 1;\n                var handlerData = this._handlers[topIndex];\n                handlerData.handler(config);\n            } catch (e) {\n                dx.fail(e.message);\n            }\n        } else {\n            dx.fail('Invalid configuration for jQuery ajax call. Unable to complete the operation.');\n        }\n    }\n};\n\ndx.core.ajax.resetAjaxHandlers();\nBackbone.ajax = function() {\n    return dx.core.ajax.ajaxCall.apply(dx.core.ajax, arguments);\n}\n\n})();",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2013, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _ */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n\n/*\n * Do top-level processing of each schema. This involves:\n *  1) If the schema has no name, replace it with a name, based on the schemaKey, that can be used as a Javascript\n *     identifier.\n *  2) Replace the extends schemaKey (if present) with the name of the parent schema.\n *  3) Add a parentSchema property with a reference to the parent schema, if any.\n *  4) Add the name of the closest ancestor schema type that had a root property.\n *  5) Inherit the parent's root property, if this itself doesn't have one.\n */\nfunction processSchema(schema, schemaKey, sourceSchemas, newSchemas, preserveUnneeded) {\n    /*\n     * Most schemas have a name. However, not all do.  We must nevertheless expose those schemas as they have root\n     * operations on them. Thus, we convert the key into a form that can be used to identify them.\n     */\n    schema.name = schemaKeyToTypeName(schemaKey, sourceSchemas);\n\n    // If this schema has already been processed (see recursive call, below), return it\n    if (newSchemas[schema.name]) {\n        return newSchemas[schema.name];\n    }\n\n    newSchemas[schema.name] = schema;\n\n    if (schema.root) {\n        schema.rootTypeName = schema.name;\n    }\n\n    // Process the parent schema, if any. This assumes all extends schemas have just a $ref property.\n    var parentSchema = schema.extends;\n    if (parentSchema) {\n        schema.parentSchema = processSchema(sourceSchemas[parentSchema.$ref], parentSchema.$ref,\n            sourceSchemas, newSchemas);\n        parentSchema.$ref = schemaKeyToTypeName(parentSchema.$ref, sourceSchemas);\n        parentSchema = schema.parentSchema;\n\n        if (!schema.rootTypeName) {\n            schema.rootTypeName = parentSchema.rootTypeName;\n        }\n\n        schema.root = schema.root || parentSchema.root;\n    }\n\n    if (!preserveUnneeded) {\n        delete schema.description;\n    }\n\n    processProperties(schema, parentSchema, sourceSchemas, preserveUnneeded);\n    processOperations(schema, parentSchema, sourceSchemas);\n\n    return schema;\n}\n\n/*\n * The schemaKeys we get are often of the form /some-name.json. Some of the characters that show up there can not be\n * used as a Javascript identifier, and so we modify the above into a Javascript compatible form. For example the\n * above would become some_name.\n */\nfunction schemaKeyToTypeName(schemaKey, schemas) {\n    if (!schemas[schemaKey]) {\n        dx.fail('Could not find a schema entry for ' + schemaKey);\n    }\n\n    if (schemas[schemaKey].name) {\n        return schemas[schemaKey].name;\n    }\n\n    var newString = schemaKey.replace(/\\.json$/, '')\n        .replace(/-/g, '_')\n        .replace(/\\//g, '');\n\n    return newString;\n}\n\n/*\n * Process the properties. As far as this is concerned, properties are one of:\n * A simple primitive value\n *     propertyName: {\n *         type: string|number|integer|boolean|null,\n *         [default: value]\n *     }\n *  or a simple object\n *     propertyName: {\n *         type: object\n *     }\n *  or an 'embedded object'\n *     propertyName: {\n *         type: object,\n *         $ref: schemaKey\n *     }\n *  or a 'referenced object'\n *     propertyName: {\n *         type: string,\n *         format: objectReference,\n *         [referenceTo: schemaKey]\n *     }\n *  or an array\n *     propertyName: {\n *         type: array,\n *         [items: {\n *             type: string|number|integer|boolean|null|object,\n *             [$ref: schemaKey]\n *         }]\n *     }\n *  note: $ref may only present if the type is object.\n * Also the type can be an array of any of the things above.\n *\n * Any one of these may also have these values:\n *         [create: required|optional|readonly,]\n *         [update: required|optional|readonly,]\n *         [required: true|false]\n * Note that there are many other validation related properties, but they are not altered by this processing.\n *\n * This does two things:\n *  1) provides 'property inheritance' by copying the parent's properties (if any) and replacing them as appropriate\n *     with this schema's properties.\n *  2) Replaces any references to schema types with the type name of the target types.\n */\nfunction processProperties(schema, parentSchema, sourceSchemas, preserveUnneeded) {\n    if (!schema.properties && !(parentSchema && parentSchema.properties)) {\n        return;\n    }\n\n    var parentProps = (parentSchema && parentSchema.properties) ? _.clone(parentSchema.properties) : {};\n    var propKeys = _.keys(schema.properties || {});\n    schema.properties = _.extend(schema.properties || {}, _.omit(parentProps, propKeys));\n\n    // Modify any of the schemas own properties\n    _.each(propKeys, function(propName) {\n        var propData = schema.properties[propName];\n\n        convertTypeReference(propData, sourceSchemas);\n\n        if (!preserveUnneeded) {\n            delete propData.description;\n        }\n    });\n}\n\n/*\n * Process all operations. these look like the following:\n *     operations: {\n *         operationName: { ... details ... },\n *         ...\n *     }\n * or\n *     rootOperations: {\n *         operationName: { ... details ... },\n *         ...\n *     }\n * or one of the following\n *     create: { ... details ... }\n *     read: { ... details ... }\n *     list: { ... details ... }\n *     update: { ... details ... }\n *     delete: { ... details ... }\n *\n * This makes the following changes to these schemas:\n *  1) Schemas that are extensions of a root schema will inherit their parents' operations\n *  2) Standard operations update, delete and read are propogated down to child objects. List and create are not\n */\nfunction processOperations(schema, parentSchema, sourceSchemas) {\n    // Do some schema validation\n    var schemaOps = _.pick(schema, ['operations', 'rootOperations', 'create', 'read', 'list', 'update', 'delete']);\n    if (!schema.root && !_.isEmpty(schemaOps)) {\n        dx.fail('Found ' + _.keys(schemaOps) + ' on a non-root schema.');\n    }\n\n    if (schema.operations && parentSchema && parentSchema.operations) {\n        dx.fail('Both ' + parentSchema.name + ' and ' + schema.name + ' have operations. This isn\\'t supported.');\n    }\n\n    var parentOps = (parentSchema && parentSchema.operations) ? parentSchema.operations : {};\n    var opKeys = schema.operations ? _.keys(schema.operations) : [];\n    var myOperations = _.extend(schema.operations || {}, _.omit(parentOps, opKeys));\n\n    if (!_.isEmpty(myOperations)) {\n        schema.operations = myOperations;\n\n        _.each(opKeys, function(opName) {\n            processOperation(schema.operations[opName], opName, sourceSchemas);\n        });\n    }\n\n    _.each(schema.rootOperations, function(opInfo, opName) {\n        processOperation(opInfo, opName, sourceSchemas);\n    });\n\n    var pSchema = parentSchema || {};\n    _.each(['create', 'update', 'read', 'list', 'delete'], function(opName) {\n        var opDef = schema[opName];\n        if (!dx.core.util.isNone(opDef)) {\n            if (opName === 'create' || opName === 'update') {\n               opDef.validateAs = opDef.validateAs || opName;\n            }\n\n            processOperation(opDef, opName, sourceSchemas);\n        }\n\n        if (opName !== 'create' && opName !== 'list') {\n            schema[opName] = opDef || pSchema[opName];\n        }\n    });\n}\n\n/*\n * Process each operation. This generalizes across standard, object and root operations. These are expected to be of\n * the form:\n *     operationName: {\n *         payload: {\n *             [type: 'object',\n *             $ref: url-to-type]\n *         }\n *         [validateAs: create|update]\n *         [required: true|false]\n *         [return: ...]\n *     }\n * or\n *     operationName: {\n *         parameters: {\n *             ...\n *         }\n *         [return: ...]\n *     }\n * or the following, which means a GET with no parameters\n *     operationName: {\n *     }\n * Any one of those may have a 'sub-operation' of the same form (though, the last, with neither payload nor\n * parameters defined will be recognized, simply because it is ambiguous with other entries).\n *         subOpName: {\n *             payload: {...},\n *             [validateAs: create|update]\n *             [return: ...]\n *          }\n * or\n *         subOpName: {\n *             parameters: {...},\n *             [return: ...]\n *          }\n * The parameters are expected to be one of the following forms:\n *     paramName: {\n *         type: typeName,\n *         [format: formatValue],\n *         [enum: [values...]],\n *         [default: defaultValue]\n *         [required: true|false]\n *     }\n * or\n *     paramName: {\n *         type: 'string',\n *         format: 'objectReference',\n *         referenceTo: schemaKey\n *         [required: true|false]\n *     }\n * While, the return value is expected to be one of the following:\n *     return : {\n *        type: typeName,\n *         [format: formatValue]\n *     }\n * or\n *     return : {\n *        type: typeName,\n *         [$ref: schemaKey]\n *     }\n * or\n *     return : {\n *        type: 'array',\n *         [items: {\n *             $ref: schemaKey\n *         }]\n *     }\n * or\n *     return : {\n *        type: 'array',\n *         [items: {\n *             referenceTo: schemaKey\n *         }]\n *     }\n * These will be modified in these ways:\n *  1) $ref and referenceTo's will be set to type name of the relevant schemas\n *  2) Any sub-operation is extracted from its default location, and put into a sub-object called dxOperations\n *  3) in the case of a 'missing' parameters, an empty one will be inserted.\n *  4) Any $ref in the return value or the return.items value will be replaced with the type name of the schema.\n * Thus, we get:\n * {\n *     payload: {\n *         ...payload properties...\n *         $ref: <related schema>\n *     }\n *     validateAs: create|update,\n *     [dxOperations: {\n *         // sub-operations\n *     }]\n * }\n * or\n * {\n *     parameters: {\n *         ... parameters info, with any referenceTo's set to the actual related schema ...\n *     },\n *     [dxOperations: {\n *         // sub-operations\n *     }]\n * }\n */\nfunction processOperation(opDef, opName, sourceSchemas) {\n    if (opDef.payload) {\n        if (opDef.parameters) {\n            dx.fail('Found both a payload and a parameters for the operation ' + opName + '.');\n        }\n        if (opDef.payload.$ref) {\n            opDef.payload.$ref = schemaKeyToTypeName(opDef.payload.$ref, sourceSchemas);\n        }\n    } else {\n        opDef.parameters = opDef.parameters || {};\n\n        _.each(opDef.parameters, function(value) {\n            if (value.referenceTo) {\n                value.referenceTo = schemaKeyToTypeName(value.referenceTo, sourceSchemas);\n            }\n        });\n    }\n\n    if (opDef.return) {\n        convertTypeReference(opDef.return, sourceSchemas);\n    }\n\n    // Move any sub-operations into a sub-object\n    _.each(opDef, function(value, key) {\n        if (key === 'payload' || key === 'parameters') {\n            return;\n        }\n        if (value.payload || value.parameters) {\n            opDef.dxOperations = opDef.dxOperations || {};\n            opDef.dxOperations[key] = processOperation(value, opName + '.' + key, sourceSchemas);\n            delete opDef[key];\n        }\n    });\n\n    return opDef;\n}\n\n/*\n * Given a type reference (a property type definition, or a return value definition), convert any references to\n * schema types from schemaKey format to the actual type name.\n */\nfunction convertTypeReference(propData, sourceSchemas) {\n    function convertReferences(type, propData) {\n        if (type === 'array' && _.has(propData, 'items')) {\n            if (_.has(propData.items, '$ref')) {\n                propData.items.$ref = schemaKeyToTypeName(propData.items.$ref, sourceSchemas);\n            } else if (_.has(propData.items, 'referenceTo')) {\n                propData.items.referenceTo = schemaKeyToTypeName(propData.items.referenceTo, sourceSchemas);\n            }\n        }\n\n        if (type === 'string' && propData.format === 'objectReference' && propData.referenceTo) {\n            propData.referenceTo = schemaKeyToTypeName(propData.referenceTo, sourceSchemas);\n        }\n\n        if (type === 'object' && propData.$ref) {\n            propData.$ref = schemaKeyToTypeName(propData.$ref, sourceSchemas);\n        }\n    }\n\n    if (_.isArray(propData.type)) {\n        _.each(propData.type, function(typeItem) {\n            convertReferences(typeItem, propData);\n        });\n    } else {\n        convertReferences(propData.type, propData);\n    }\n}\n\n/*\n * Walk through each list operation, and add a dxFilterMode property to each. The values are:\n *    none: There are no query parameters, no filter is needed\n *    uber: Every parameter has a mapsTo property, so the uberFilter can be used\n *    custom: Not enough information. A custom filter will be needed.\n */\nfunction markListOperations(schemas) {\n    _.each(schemas, function(schema) {\n        if (schema.list) {\n            if (_.isEmpty(schema.list.parameters)) {\n                schema.list.dxFilterMode = dx.core.constants.LIST_TYPES.NONE;\n            } else {\n                var missingMapsTo = false;\n                _.any(schema.list.parameters, function(param) {\n                    if (!param.mapsTo) {\n                        missingMapsTo = true;\n                        return true;\n                    }\n                });\n                schema.list.dxFilterMode = missingMapsTo ? dx.core.constants.LIST_TYPES.CUSTOM :\n                    dx.core.constants.LIST_TYPES.UBER;\n            }\n        }\n    });\n}\n\n/*\n * Given a set of schemas, modify them so that they are more easily consumable by other layers of the data system.\n *\n * Specifically, this expects the schemas to come in the form:\n * {\n *     'schemaKey': {\n *        [name: typeName,]\n *        [singleton: true|false,]\n *        [extends: { $ref: 'schemaKey' },]\n *        [root: 'url-fragment',]\n *        [properties: {...},]\n *        [create: {...},]\n *        [read: {...},]\n *        [list: {...},]\n *        [update: {...},]\n *        [delete: {...},]\n *        [operations: {...},]\n *        [rootOperations: {...}]\n *     },\n *     ...\n * }\n * Each schema may include other properties, but this will ignore them.\n *\n * The return value from this routine is a new version of the schemas, with modifications as discussed in each section\n * below.\n *\n * schemas:               The set of schemas to be prepared.  This is the only parameter that must be provided.\n * copySchemas:           If truthy, this will make a copy of the provided schemas before making changes to them.\n *                        Otherwise the original schema objects will be altered.\n * preserveUnneeded:      If truthy, properties like 'description' that aren't needed will not be deleted.\n */\nfunction prepareSchemas(schemas, copySchemas, preserveUnneeded) {\n    var newSchemas = {};\n\n    if (!_.isObject(schemas)) {\n        dx.fail('Must provide a schemas object.');\n    }\n\n    // Always copy the schemas at this time, as it caused model-generator to be unhappy.\n    if (copySchemas || true) {\n        schemas = dx.core.util.deepClone(schemas);\n    }\n\n    _.each(schemas, function(value, key) {\n        processSchema(value, key, schemas, newSchemas, preserveUnneeded);\n    });\n    \n    /*\n     * Finally, add a flag to each list operation to determine whether it can be generically filtered, or whether\n     * it needs help\n     */\n    markListOperations(newSchemas);\n\n    return newSchemas;\n}\n\n/*\n * Given a set of prepared schemas, this will find enums that are properties of a type and enums that are defined as\n * parameters of list, object, and root operations.  The expected input format of the prepared schemas is as follows:\n *\n *  {\n *      typeName: {\n *          [properties: {\n *              propertyName: {\n *                  enum: [value, ...]\n *              },\n *              arrayPropertyName: {\n *                  items: {\n *                      enum: [value, ...]\n *                  }\n *              }\n *          },]\n *          [list: {\n *              parameters: {\n *                  parameterName: {\n *                      enum: [value, ...]\n *                  }\n *              }\n *          },]\n *          [rootOperations|operations: {\n *              operationName: {\n *                  parameters: {...}\n *              }\n *          }]\n *      }\n *  }\n *\n * No specific types, properties or parameters are required, and excess properties will be ignored.  The output is an\n * object where each type and its enums can be accessed as properties:\n *\n *  {\n *      typeName: {\n *          (property|operation)Name: {\n *              value: value\n *              ...\n *          }\n *      }\n *  }\n *\n */\nfunction prepareEnums(schemas) {\n    var enums = {};\n\n    if (!_.isObject(schemas)) {\n        dx.fail('Must provide a set of prepared schemas.');\n    }\n\n    function processEnum(type, name, definition) {\n        var enumType = enums[type] = enums[type] || {};\n        var enumProp = enumType[name] = enumType[name] || {};\n        _.each(definition.enum, function(enumVal) {\n            enumProp[enumVal] = enumVal;\n        });\n    }\n\n    function processParameters(type, opDef) {\n        _.each(opDef.parameters, function(paramDef, paramName) {\n            if (paramDef.enum) {\n                processEnum(type, paramName, paramDef);\n            }\n        });\n    }\n\n    _.each(schemas, function(schema, type) {\n        _.each(schema.properties, function(propDef, propName) {\n            if (propDef.enum) {\n                processEnum(type, propName, propDef);\n            // Array of enums\n            } else if (propDef.items && propDef.items.enum) {\n                processEnum(type, propName, propDef.items);\n            }\n        });\n\n        // Collect enums from list, root operation, and object operation parameters\n        if (schema.list) {\n            processParameters(type, schema.list);\n        }\n        _.each(schema.rootOperations, function(rootOpDef) {\n            processParameters(type, rootOpDef);\n        });\n        _.each(schema.operations, function(opDef) {\n            processParameters(type, opDef);\n        });\n    });\n\n    return enums;\n}\n\n_.extend(dx.core.data, {\n    _prepareSchemas: prepareSchemas,\n    _prepareEnums: prepareEnums\n});\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _, Backbone */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n\nfunction dumpEventListners(eventLadenObject) {\n    var functionNameRegEx = /.*function *([^ \\(]*) *\\(/;\n    _.each(eventLadenObject._events, function(listenerArray, eventName) {\n        var anonymousCount = 0;\n        var callbackNames = _.reduce(listenerArray, function(memo, item) {\n            if (item.callback) {\n                var functionString = item.callback.toString();\n                var functionName = functionString.match(functionNameRegEx);\n                if (functionName && functionName[1] !== '') {\n                    memo.push(functionName[1]);\n                } else {\n                    anonymousCount++;\n                }\n            }\n            return memo;\n        }, []);\n\n        // Don't show the internal callbacks used by this cache to mange the models. These never affect prune().\n        if (callbackNames.length === 1 &&\n            (eventName === 'badReference' && callbackNames[0] === 'handle404' ||\n            eventName === 'change' && callbackNames[0] === 'updateCollections')) {\n            return;\n        }\n        var suffix = callbackNames.length === 0 ? '' : '. ' + callbackNames.join(',');\n        if (anonymousCount > 0) {\n            suffix += ' (' + anonymousCount + ' anonymous)';\n        }\n        dx.info('   ' + eventName + ' : ' + listenerArray.length + ' callbacks' + suffix);\n    });\n}\n\n/*\n * A simple cache of subscribers (collections or notification listeners).  Note that these are stored by the type that\n * the list operation for the specified type returns, which in some cases is different than the specified type.\n * This is a private type, so it does no checking of arguments.\n */\nfunction ModelSubscriberStore() {\n    var modelSubscribersByType = {};\n\n    function forEachSubscription(functionToApply) {\n        _.each(modelSubscribersByType, function(subscriber) {\n            _.each(subscriber, functionToApply);\n        });\n    }\n\n    function add(subscriber) {\n        var baseType = subscriber._dxInfo.baseType;\n        modelSubscribersByType[baseType] = modelSubscribersByType[baseType] || [];\n\n        if (modelSubscribersByType[baseType].indexOf(subscriber) === -1) {\n            modelSubscribersByType[baseType].push(subscriber);\n        }\n    }\n\n    function remove(subscriber) {\n        var baseType = subscriber._dxInfo.baseType;\n        var index = modelSubscribersByType[baseType].indexOf(subscriber);\n        if (index !== -1) {\n            if (subscriber instanceof Backbone.Collection) {\n                subscriber.clear();\n            }\n            modelSubscribersByType[baseType].splice(index, 1);\n\n            if (_.isEmpty(modelSubscribersByType[baseType])) {\n                delete modelSubscribersByType[baseType];\n            }\n        }\n    }\n\n    function hasType(typeName) {\n        return !!modelSubscribersByType[typeName];\n    }\n\n    function getAllOfType(typeName) {\n        return modelSubscribersByType[typeName] || [];\n    }\n\n    /*\n     * Forcibly empty all collections in the store, and then remove all subscribers\n     */\n    function reset() {\n        var toRemove = [];\n\n        // accumulate the items to remove\n        forEachSubscription(function(subscriber) {\n            toRemove.push(subscriber);\n        });\n\n        // now remove them (removing while accumulating can mess up the loops)\n        _.each(toRemove, remove);\n    }\n\n    /*\n     * Remove all subscribers that have no more listeners\n     */\n    function prune() {\n        var toRemove = [];\n\n        forEachSubscription(function(subscriber) {\n            if (subscriber instanceof Backbone.Collection) {\n                if (_.isEmpty(subscriber._events)) {\n                    toRemove.push(subscriber);\n                }\n            } else if (!subscriber.inUse) {\n                // it is a creation Listener\n                toRemove.push(subscriber);\n            }\n        });\n\n        _.each(toRemove, remove);\n    }\n\n    /*\n     * Returns:\n     *    true: If the store has no subscribers\n     *    false: if the store has one or more subscribers\n     */\n    function isEmpty() {\n        return _.isEmpty(modelSubscribersByType);\n    }\n\n    /*\n     * Write out the subscribers.\n     */\n    function dump() {\n        dx.info('SUBSCRIBERS');\n        dx.info('===========');\n        dx.info(modelSubscribersByType);\n    }\n\n    function dumpText() {\n        dx.info('SUBSCRIBERS');\n        dx.info('===========');\n        if (_.isEmpty(modelSubscribersByType)) {\n            dx.info('None.');\n        }\n        var types = _.keys(modelSubscribersByType);\n        _.each(types.sort(), function(typeName) {\n            dx.info(typeName);\n            dx.info('-------------');\n            _.each(modelSubscribersByType[typeName], function(subscriber) {\n                if (subscriber instanceof Backbone.Collection) {\n                    var collection = subscriber;\n                    var references = collection.reduce(function(memo, item) {\n                        if (item.id) {\n                            memo.push(item.id);\n                        }\n                        return memo;\n                    }, []);\n\n                    var suffix = references.length === 0 ? '' :  '. IDs: ' + references.join(', ');\n                    dx.info('   ' + collection.length + ' model collection' + suffix);\n                    dumpEventListners(collection);\n                } else {\n                    var qp = subscriber.getQueryParameters();\n                    dx.info('Notification Listener with query params: ' + (qp ? JSON.stringify(qp) : 'None'));\n                }\n            });\n        });\n    }\n\n    return {\n        _modelSubscribers: modelSubscribersByType,\n        add: add,\n        remove: remove,\n        hasType: hasType,\n        getAllOfType: getAllOfType,\n        reset: reset,\n        dump: dump,\n        prune: prune,\n        isEmpty: isEmpty,\n        dumpText: dumpText\n    };\n}\n\n/*\n * A simple cache of singletons.  This is a private type, so it does no checking of arguments.\n */\nfunction SingletonStore() {\n    var singletons = {};\n\n    function add(singleton) {\n        singletons[singleton.get('type')] = singleton;\n    }\n\n    function get(typeName) {\n        return singletons[typeName];\n    }\n\n    function remove(singleton) {\n        if (!_.isUndefined(singletons[singleton.get('type')])) {\n            delete singletons[singleton.get('type')];\n        }\n    }\n\n    function hasType(typeName) {\n        return !!singletons[typeName];\n    }\n\n    /*\n     * Forcibly remove all singletons\n     */\n    function reset() {\n        _.each(_.keys(singletons), function(typeName) {\n            delete singletons[typeName];\n        });\n    }\n\n    /*\n     * Remove all singletons that have no more listeners\n     */\n    function prune() {\n        var toRemove = _.filter(singletons, function(singleton) {\n            return _.isEmpty(singleton._events);\n        });\n\n        _.each(toRemove, function(model) {\n            delete singletons[model.get('type')];\n        });\n    }\n\n    /*\n     * Returns:\n     *    true: If the store has no singletons\n     *    false: if the store has one or more singletons\n     */\n    function isEmpty() {\n        return _.isEmpty(singletons);\n    }\n\n    /*\n     * Write out the singletons.\n     */\n    function dump() {\n        dx.info('SINGLETONS');\n        dx.info('==========');\n        dx.info(singletons);\n    }\n\n    function dumpText() {\n        dx.info('SINGLETONS');\n        dx.info('==========');\n        if (_.isEmpty(singletons)) {\n            dx.info('None.');\n        }\n        _.each(singletons, function(singleton, typeName) {\n            dx.info(typeName);\n            dumpEventListners(singleton);\n        });\n    }\n\n    return {\n        _singletons: singletons,\n        add: add,\n        get: get,\n        remove: remove,\n        hasType: hasType,\n        reset: reset,\n        dump: dump,\n        prune: prune,\n        isEmpty: isEmpty,\n        dumpText: dumpText\n    };\n}\n\n/*\n * A simple cache of models.  These are organized by root type, then reference. This is a private type, so it does no\n * signifianct checking of arguments.\n */\nfunction ModelStore(context) {\n    var modelsByTypeThenRef = {};\n\n    function forEachModel(functionToApply) {\n        _.each(modelsByTypeThenRef, function(models) {\n            _.each(models, functionToApply);\n        });\n    }\n\n    function add(model) {\n        var rootType = context._getRootType(model.get('type'));\n        var reference = model.get('reference');\n        modelsByTypeThenRef[rootType] = modelsByTypeThenRef[rootType] || {};\n\n        if (dx.core.util.isNone(reference)) {\n            dx.fail('Can not cache a model with no reference (type is: ' + model.get('type') + ').');\n        }\n\n        modelsByTypeThenRef[rootType][reference] = model;\n    }\n\n    // typeName is optional\n    function get(reference, typeName) {\n        if (_.isUndefined(typeName)) {\n            var result;\n            _.find(modelsByTypeThenRef, function(models) {\n                return _.find(models, function(model, modelReference) {\n                    if (modelReference === reference) {\n                        result = model;\n                        return true;\n                    }\n                });\n            });\n            return result;\n        } else {\n            return modelsByTypeThenRef[typeName] ? modelsByTypeThenRef[typeName][reference] : undefined;\n        }\n    }\n\n    function remove(model) {\n        var rootType = context._getRootType(model.get('type'));\n        var reference = model.get('reference');\n        modelsByTypeThenRef[rootType] = modelsByTypeThenRef[rootType] || [];\n        model.off(undefined, undefined, context);\n\n        delete modelsByTypeThenRef[rootType][reference];\n\n        if (_.isEmpty(modelsByTypeThenRef[rootType])) {\n            delete modelsByTypeThenRef[rootType];\n        }\n    }\n\n    function hasModel(reference) {\n        return !!get(reference);\n    }\n\n    /*\n     * Forcibly remove all models\n     */\n    function reset() {\n        var toRemove = [];\n\n        forEachModel(function(model) {\n            toRemove.push(model);\n        });\n\n        _.each(toRemove, remove);\n    }\n\n    /*\n     * Remove all models that have no more listeners\n     */\n    function prune() {\n        var toRemove = {};\n\n        forEachModel(function(model, reference) {\n            var events = model._events || {};\n            /*\n             * Our model creation system currently sets up listeners on badReference and change.  If a model has\n             * only one listener for each event, we want to ignore them when we consider whether the model has any\n             * listeners that should prevent it from being pruned. (we don't mind pruning something that only has\n             * listeners set up by the model creation system)\n             */\n            var hasCachingListeners = events.badReference && events.badReference.length === 1 &&\n                events.change && events.change.length === 1;\n            var listeners = hasCachingListeners ? _.omit(events, ['badReference', 'change']) : events;\n\n            if (_.isEmpty(listeners)) {\n                toRemove[reference] = model;\n            }\n        });\n\n        _.each(toRemove, remove);\n    }\n\n    /*\n     * Returns:\n     *    true: If the store has no models\n     *    false: if the store has one or more models\n     */\n    function isEmpty() {\n        return _.isEmpty(modelsByTypeThenRef);\n    }\n\n    /*\n     * Write out the models.\n     */\n    function dump() {\n        dx.info('SERVER MODELS');\n        dx.info('=============');\n        dx.info(modelsByTypeThenRef);\n    }\n\n    function dumpText() {\n        dx.info('SERVER MODELS');\n        dx.info('=============');\n        if (_.isEmpty(modelsByTypeThenRef)) {\n            dx.info('None.');\n        }\n        var types = _.keys(modelsByTypeThenRef);\n        _.each(types.sort(), function(typeName) {\n            dx.info(typeName);\n            dx.info('-------------');\n            var references = _.keys(modelsByTypeThenRef[typeName]);\n            _.each(references.sort(), function(reference) {\n                var model = modelsByTypeThenRef[typeName][reference];\n                dx.info(reference);\n                dumpEventListners(model);\n            });\n        });\n    }\n\n    return {\n        _models: modelsByTypeThenRef,\n        add: add,\n        get: get,\n        remove: remove,\n        hasModel: hasModel,\n        reset: reset,\n        dump: dump,\n        prune: prune,\n        isEmpty: isEmpty,\n        dumpText: dumpText\n    };\n}\n\n/*\n * This portion of the data system provides a cache of models and subscribers, collections and notification listeners.\n * It ensures that models are unique (that is, there is only one instance for a particular reference), it makes sure\n * all collections contain the models that they legitimately could contain, and subscribers are notified of new\n * models.\n *\n * There are four primary uses:\n *   - Someone retrieves data from the server. It would call getCachedModelFromProperties() which will create or update\n *     a model using those properties, and return the model to the caller.\n *   - Someone wants to retrieve a particular model. It calls getCachedModel(), which returns the requested model (and\n *     does a fetch on it, if necessary)\n *   - Someone wants to get a singleton: so it calls getCachedSingleton() which returns the unique singleton instance.\n *   - Someone wants a collection or notification subscribers of a particular type. They create the data structure\n *     and call _modelSubscribersStore.add to make sure the subscribers gets notified of changes and collections\n *     updated.\n *\n * This entire cache system is 'private' to the data system, and should not be called from outside.\n *\n * Unless reset() is called, at this time models and collections are never discarded.\n *\n * As with other parts of the data system, this takes a 'context' object, and attaches a _cache object to that one,\n * where private (to the data system) caching routines reside. The intent here is to make sure that if needed multiple\n * data systems can co-exist.\n */\ndx.core.data._initCache = function(context) {\n    /*\n     * Return a singleton of the specified type. If it doesn't already exist, a new model is created, cached, and\n     * returned.  If 'update' is true, then this will fetch new data for the model.\n     * typeName:   The type of the singleton\n     * options:    JSON object with these optional properties:\n     *               update: {true|false}  Will cause an update (fetch) on the model\n     *               success: A function to call when the model is ready\n     *               error: A function to call when an error occurred during a fetch\n     */\n    function getCachedSingleton(typeName, options) {\n        if (!_.isString(typeName)) {\n            dx.fail('A type name must be passed to get the singleton.');\n        }\n        options = options || {};\n        var model;\n        var isNew;\n        if (context._singletonStore.hasType(typeName)) {\n            model = context._singletonStore.get(typeName);\n            if (options.success) {\n                options.success(model);\n            }\n        } else {\n            var schema = assertTypeAndGetModelSchema(typeName);\n\n            if (!schema.singleton) {\n                dx.fail(typeName + ' is not a singleton.');\n            }\n\n            model = context._newServerModel(typeName);\n            context._singletonStore.add(model);\n            isNew = true;\n        }\n\n        if (options.update || isNew) {\n            var fetchOpts = options;\n            if (isNew) {\n                fetchOpts = {\n                    success: options.success,\n                    error: function(result) {\n                        context._singletonStore.remove(model);\n                        if (options.error) {\n                            options.error(result);\n                        } else if (!options.suppressDefaultErrorHandler) {\n                            context.reportErrorResult(result);\n                        }\n                    }\n                };\n            }\n            model._dxFetch(fetchOpts);\n        }\n\n        return model;\n    }\n\n    /*\n     * Given a set of properties, either update an existing model with the same reference as in the properties\n     * object, or create a new server model, populate it with these properties, cache it and return it.\n     *\n     * properties: A JSON object containing properties that can be set() on a DSB model\n     * options:    Backbone options\n     */\n    function getCachedModelFromProperties(properties, options) {\n        var model;\n\n        if (!_.isObject(properties) || !_.isString(properties.type)) {\n            dx.fail('Must be called with an object that has a type property that is a string value.');\n        }\n\n        if (!context._modelConstructors[properties.type]) {\n            dx.fail('Don\\'t know how to create a model of type ' + properties.type + '.');\n        }\n\n        // Not all types have a reference property. Those that do not are not cachable. Assume this is a client model\n        if (!isTypeCachable(properties.type) || dx.core.util.isNone(properties.reference)) {\n            model = context._newClientModel(properties.type);\n            model._dxSet(properties);\n            return model;\n        }\n\n        var rootType = context._getRootType(properties.type);\n        model = context._modelStore.get(properties.reference, rootType);\n        if (_.isUndefined(model)) {\n            model = makeModel(properties, properties.type, rootType);\n            model._dxMakeReady();\n            addModel(model, rootType, options);\n        } else {\n            model._dxSet(properties);\n        }\n\n        return model;\n    }\n\n    /*\n     * Returns a cached model with the specified reference.  If the model isn't in the cache, this will return\n     * a new model, which it will also fetch. If the update argument is true, it will be\n     * fetched regardless of whether it is new or old.\n     *\n     * reference:  The reference of the model to retrieve\n     * typeName:   The type of the model @@@@ why isn't this the root type?\n     * options:    JSON object with these optional properties:\n     *               update: {true|false}  Will cause an update (fetch) on the model\n     *               cacheOnlyIfNeeded: {true|false} Add to the cache (and return) only if there are already\n     *                  collections that would use it.\n     *               suppressDefaultErrorHandler: {true|false} Do not trigger the default error handler on dxFetch\n     */\n    function getCachedModel(reference, typeName, options) {\n        if (!_.isString(reference) || !_.isString(typeName)) {\n            dx.fail('A reference and a type must be passed to get the model.');\n        }\n        options = options || {};\n\n        var isNew = false;\n        var rootType = context._getRootType(typeName);\n        var mustCache = !options.cacheOnlyIfNeeded;\n        var haveSubscriptionWhichNeedsModel = (context._modelSubscribersStore.getAllOfType(rootType).length !== 0);\n        var addToCache = mustCache || haveSubscriptionWhichNeedsModel;\n\n        var model = context._modelStore.get(reference, rootType);\n        if (_.isUndefined(model) && addToCache) {\n            model = makeModel({ reference: reference }, typeName, rootType);\n            isNew = true;\n        }\n\n        if (model && (options.update || isNew)) {\n            model._dxFetch({\n                success: function() {\n                    if (isNew) {\n                        addModel(model, rootType);\n                    }\n                },\n                error: function(result) {\n                    if (isNew) {\n                        context._modelStore.remove(model);\n                    }\n                    if (!options || !options.suppressDefaultErrorHandler) {\n                        context.reportErrorResult(result);\n                    }\n                }\n            });\n        }\n\n        return model;\n    }\n\n    /*\n     * Returns true if the cache contains a model with the specified reference\n     */\n    function containsCachedModel(reference, typeName) {\n        if (!_.isString(reference) || !_.isString(typeName)) {\n            dx.fail('A reference and a type must be passed to check on the model.');\n        }\n\n        return !_.isUndefined(context._modelStore.get(reference, context._getRootType(typeName)));\n    }\n\n    /*\n     * Deletes the model. This means removing it from the cache, as well as from any\n     * collections that contain it, and clears the model's properties.\n     * If the dontTriggerDelete flag is not set, this will also trigger a 'delete' event on the model.\n     */\n    function deleteCachedModel(reference, typeName, dontTriggerDelete) {\n        if (!_.isString(reference) || !_.isString(typeName)) {\n            dx.fail('A reference and a type must be passed to delete a model.');\n        }\n\n        var rootType = context._getRootType(typeName);\n        var doomed = context._modelStore.get(reference, rootType);\n        if (!doomed) {\n            return;\n        }\n\n        _.each(context._modelSubscribersStore.getAllOfType(rootType), function(subscriber) {\n            if (subscriber instanceof Backbone.Collection) {\n                subscriber._dxRemoveModel(doomed);\n            }\n        });\n\n        if (!dontTriggerDelete) {\n            doomed.trigger('delete', doomed);\n        }\n        doomed.off(null, null, context);\n        context._modelStore.remove(doomed);\n        doomed._dxClear();\n        doomed._dxDeleted = true;\n    }\n\n    /*\n     * Remove all references we have to both singletons and server models.\n     */\n    function resetCache() {\n        context._modelSubscribersStore.reset();\n        context._singletonStore.reset();\n        context._modelStore.reset();\n    }\n\n    /*\n     * Dump the types (for singletons) and references (for server models) as text for all objects in the cache.\n     */\n    function dumpCacheAsText() {\n        context._modelSubscribersStore.dumpText();\n        dx.info('');\n\n        context._singletonStore.dumpText();\n        dx.info('');\n\n        context._modelStore.dumpText();\n    }\n\n    /*\n     * Dump the internal singletons and model data structures.  This is usable on most browsers.\n     */\n    function dumpCache() {\n        context._modelSubscribersStore.dump();\n        dx.info('');\n\n        context._singletonStore.dump();\n        dx.info('');\n\n        context._modelStore.dump();\n        dx.info('');\n    }\n\n    function prune() {\n        context._modelSubscribersStore.prune();\n        context._singletonStore.prune();\n        context._modelStore.prune();\n    }\n\n    function isEmpty() {\n        return context._modelSubscribersStore.isEmpty() &&\n            context._singletonStore.isEmpty() &&\n            context._modelStore.isEmpty();\n    }\n\n    /*\n     * Creates a model, sticks it in the cache, and sets up to cope with badReferences\n     */\n    function makeModel(properties, typeName, rootType) {\n        var model = context._newServerModel(typeName);\n        model._dxSet(properties);\n        context._modelStore.add(model);\n        model.on('badReference', function handle404() {\n            deleteCachedModel(properties.reference, rootType, true);\n        }, context);\n\n        return model;\n    }\n\n    /*\n     * Adds the specified model to the collections\n     */\n    function addModel(model, rootType, options) {\n        /*\n         * Recheck whether the model should be added to collections any time it changes.\n         * This does not apply for subscribers which only need to be notified once for each object.\n         */\n        model.on('change', function updateCollections() {\n            notifySubscriptionsOfModelChanged(model, rootType);\n        }, context);\n        notifySubscriptionsOfModel(model, rootType, options);\n    }\n\n    /*\n     * Adds the specified model to all relevant subscribers (collections or notification listeners).\n     */\n    function notifySubscriptionsOfModel(model, rootType, options) {\n        _.each(context._modelSubscribersStore.getAllOfType(rootType), function(subscriber) {\n            subscriber._dxAddOrRemove(model, options);\n        });\n    }\n\n    /*\n     * Notifies collections that the model has changed.\n     */\n    function notifySubscriptionsOfModelChanged(model, rootType, options) {\n        _.each(context._modelSubscribersStore.getAllOfType(rootType), function(subscriber) {\n            if (subscriber instanceof Backbone.Collection) {\n                subscriber._dxAddOrRemove(model, options);\n            }\n        });\n    }\n\n    /*\n     * Asserts that the type is a valid model type, and returns its schema.\n     */\n    function assertTypeAndGetModelSchema(typeName) {\n        var ModelConstructor = context._modelConstructors[typeName];\n\n        if (!ModelConstructor) {\n            dx.fail(typeName + ' is not a known type name.');\n        }\n\n        return ModelConstructor.prototype._dxSchema;\n    }\n\n    /*\n     * Examines the type, and returns a truthy value if it is cachable\n     */\n    function isTypeCachable(type) {\n        var Constructor = context._modelConstructors[type];\n        if (!Constructor) {\n            return false;\n        }\n        var typeDef = Constructor.prototype._dxSchema;\n        var propDefs = typeDef.properties || {};\n\n        return !!propDefs.reference;\n    }\n\n    context._modelSubscribersStore = new ModelSubscriberStore();\n    context._singletonStore = new SingletonStore();\n    context._modelStore = new ModelStore(context);\n\n    /*\n     * Make all of our public routines available.\n     */\n    context._cache = {\n        _ModelSubscriberStore: ModelSubscriberStore,\n        _SingletonStore: SingletonStore,\n        _ModelStore: ModelStore,\n        getCachedSingleton: getCachedSingleton,\n        getCachedModelFromProperties: getCachedModelFromProperties,\n        getCachedModel: getCachedModel,\n        deleteCachedModel: deleteCachedModel,\n        containsCachedModel: containsCachedModel,\n        reset: resetCache,\n        dumpText: dumpCacheAsText,\n        dump: dumpCache,\n        prune: prune,\n        isEmpty: isEmpty,\n        isTypeCachable: isTypeCachable\n    };\n};\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _, Backbone */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n/*\n * This takes a set of schemas (modified by _prepareSchemas), and creates a set of Backbone Collection constructor\n * functions (and, by implication, functionality upon the collections generated by those functions). These will be\n * used by the 'level3' API's to provide final collections to consumers of the data layer.\n *\n * See the comment for level2-models for a list of the specialized terminology used here (e.g. DSB).\n *\n * CONSTRUCTOR FUNCTIONS\n * The collections created by these constructor functions contain groups of DSB Models that all share a common parent\n * type.  These collections can only have their contents changed by way of $$list() operations and the notification\n * system. Unlike DSB models, there are no 'Client' collections.  To have a fully-alterable collection of models,\n * use an ordinary Backbone Collection.\n *\n * EVENTS\n * ready : readyHandler(collection)\n * If you want to know if a collection is ready to be used (has retrieved at least one set of results via $$list()),\n * use the 'ready' event, which is unique to DSB collections.\n * Ready indicates that the collection has retrieved an initial set of models.  Unlike ordinary events, if a ready\n * handler is assigned to a collection that is already ready, that handler (and no others) will be triggered\n * immediately. Ready handlers receive as their first (and only) argument the\n *\n * dirty : dirtyHandler(collection)\n * Indicates that the collection may be out of sync with the server and should be re-$$list()'ed\n *\n * POPULATION\n * Server collections are populated in two ways:\n *   1) A call to $$list() will fill the collection with the current set of models from the server\n *   2) The notification system, if enabled, may cause models to be added and removed from the collection at any time.\n * The operation of $$list() is straightforward.  Notifications are a little less clear.  As the notification system\n * learns of object changes, it will inform the caching system about the changes.  That, in turn will cause the\n * caching system to try to update any collections, adding and removing those models to collections as needed.\n * The decision of whether a model should be added will depend on the query parameters that currently govern the\n * collection (the ones last passed to $$list(), if any).  In some cases, a collection may have a paged set of results,\n * and at that point it can be difficult to determine whether the model should be added to the collection.\n * The filter system (level2-filter) provides per-type filters. It is their responsibility to determine how the model\n * should be dealt with. If it can't determine (as in the case with paging), the collection will trigger a 'dirty'\n * event, which the client of the collection can use to decide how to handle this case. If setAutoPageRefresh(true) has\n * been called on the collection, then in these circumstances, in addition to firing the 'dirty' event, the collection\n * will automatically re-call $$list() with the original query parameters. In this case, the original success and error\n * handlers will be called again after the list operation returns.\n *\n * OPERATIONS\n * The collections created by these constructor functions have these similarities and differences compared to the\n * standard Backbone collections.\n *\n * Standard Backbone properties (none of these should be changed)\n *     models     : -- : The set of models in the collection. Don't access directly. Use at() instead.\n *     length     :    : Standard behavior.\n *\n * Standard Backbone functions\n *     model      : -- : Must not use. Collections can not create their own models.\n *     toJSON     :    : Standard behavior.\n *     Underscore :    : Standard behavior. These are the 'underscore' functions can all be applied to collections.\n *     add        : -- : Do not use. Use $$list() instead.\n *     remove     : -- : Do not use. Use $$list() instead.\n *     reset      : -- : Do not use. Use $$list() instead.\n *     set        : -- : Do not use. Use $$list() instead.\n *     get        :    : Standard behavior.\n *     at         :    : Standard behavior.\n *     push       : -- : Do not use. Use $$list() instead.\n *     pop        : -- : Do not use. Use $$list() instead.\n *     unshift    : -- : Do not use. Use $$list() instead.\n *     shift      : -- : Do not use. Use $$list() instead.\n *     slice      :    : Standard behavior.\n *     comparator :    : Standard behavior.\n *     sort       :    : Standard behavior.\n *     pluck      :    : Standard behavior.\n *     where      :    : Standard behavior.\n *     findWhere  :    : Standard behavior.\n *     url        : -- : Internal use. Don't use.\n *     parse      : -- : Internal use. Don't use. Handles return values from the Delphix Engine\n *     clone      :    : Standard behavior. However, the returned collection is an ordinary Backbone Collection.\n *     fetch      : -- : Do not use. Use $$list() instead.\n *     create     : -- : Do not use. DSB Models have more complex creation semantics. use rootOps..$$create().\n *\n * DSB Collection functions\n *     $$list             :    : Populates the collection with a selection of models from the server.\n *     getQueryParameters :    : Returns the query parameters used to populate this collection via $$list\n *     clear              :    : Removes all models from the collection, empties any query parameters, and blocks any\n *                               models from being auto-added until another $$list is issued\n *\n * Private to dxCore Data\n *     context._collectionConstructors : The set of collection constructor functions\n *     context._newServerCollection    : Creates a new Server Collection\n *\n * Parameters:\n *     schemas: The set of schemas this should generate constructors from.\n *     context: The object to put the resulting constructors (_collectionConstructors) on. If not specified, puts them\n *              on 'this'.\n */\ndx.core.data._generateCollectionConstructors = function(schemas, context) {\n    var LISTINGMODE_IDLE = 0;\n    var LISTINGMODE_LISTING = 1;\n\n    /*\n     * ========================================\n     * Collection functions\n     * ========================================\n     */\n\n    /*\n     * Backbone defines this as: Bind a callback function to an object. The callback will be invoked whenever the event\n     * is fired.\n     *\n     * For DSB collections, we provide standard behavior for this, but do some special processing if someone is\n     * listening for the 'ready' event. In that case, if we have done a $$list() successfully, then we trigger the\n     * ready event immediately.\n     */\n    function dxOn(name, callback, context) {\n        Backbone.Events.on.call(this, name, callback, context);\n        if (name === 'ready' && this._dxIsReady) {\n            this.trigger('ready', this);\n        } else if (name === 'error' && this._dxIsErrored) {\n            this.trigger('error', this);\n        }\n    }\n\n    /*\n     * Backbone defines this as: [This] performs a 'smart' update of the collection with the passed list of models.\n     *\n     * In general, we do not allow this to be called, since server models are supposed to be read only. However,\n     * in some cases, internally, we need to add models to the collection, and wish to partake of the functionality\n     * already defined by Backbone. So, if this is called with { _dxAllowSetPassthrough:true }, it will call\n     * Backbone.Collection.set() normally.\n     *\n     * This is not simply a dxAdd function, since we need to support calls from within backbone back to model.set()\n     * that may have been triggered by other actions we have taken.\n     */\n    function dxSet(models, options) {\n        options = options || {};\n        if (!options._dxAllowSetPassthrough) {\n            operationNotAllowed();\n        }\n\n        assertModelsCompatible(models, this);\n        return Backbone.Collection.prototype.set.call(this, models, _.extend(options, {\n            merge: false,\n            remove: false\n        }));\n    }\n\n    /*\n     * Backbone defines this as: parse is called by Backbone whenever a collection's models are returned by the server,\n     * in fetch. The function is passed the raw response object, and should return the array of model attributes to be\n     * added to the collection. The default implementation is a no-op, simply passing through the JSON response.\n     * Override this if you need to work with a preexisting API, or better namespace your responses.\n     *\n     * This expects the response to always have a type attribute. If it is an ErrorResult, it gets reported through the\n     * standard error handler. If it is a ListResult, we return just the result array. Otherwise we throw an error.\n     */\n    function dxParse(response) {\n        if (!response || !response.type) {\n           dx.fail('Got a response without a type.');\n        } else if (response.type !== 'ListResult') {\n            dx.fail('Got an unexpected type of response (' + response.type + ') in parse().');\n        }\n\n        return response.result;\n    }\n\n    /*\n     * Entirely block the standard Backbone fetch() routine. We want users to call $$list(), as that has a more\n     * constrained API, better matches the api we're providing for operations and rootOperations, and, more directly\n     * maps to our schemas.\n     */\n    function dxFetch() {\n        dx.fail('Do not call fetch() directly. Instead, call $$list().');\n    }\n\n    /*\n     * Entirely block the standard Backbone create() routine. Creation is more complex for DSB models, and so should be\n     * done through the $$create operations.\n     */\n    function dxCreate() {\n        dx.fail('Do not call create() directly. Instead, call rootOps.' + this._dxInfo.baseType + '.$$create().');\n    }\n\n    /*\n     * Removes all models from the collection, but leaves it 'live'.  This is used for testing purposes.\n     */\n    function dxEmpty() {\n        Backbone.Collection.prototype.remove.call(this, this.models, {silent: true});\n    }\n\n    /*\n     * Removes all models from the collection (not silently), removes the query parameters,\n     * if any, and marks the collection as not ready, which means it must have another $$list() call in order to get\n     * new models\n     */\n    function dxClear() {\n        this._dxIsReady = false;\n        this._queryParameters = undefined;\n        Backbone.Collection.prototype.remove.call(this, this.models, {silent: true});\n        this.trigger('reset', this);\n    }\n\n    /*\n     * Given a model, this will either add it to the collection, if it should be in the collection, ignore it if it\n     * shouldn't be in the collection (and isn't there already), or remove it if it shouldn't be in the collection and\n     * is.  This takes into account any query parameters associated with the collection, and uses collection filters\n     * if defined.\n     *\n     * Note that models can be neither added nor removed if this is not ready.\n     */\n    function dxAddOrRemove(model, options) {\n        assertModelsCompatible(model, this);\n        if (!this._dxIsReady) {\n            return;\n        }\n        options = _.extend({\n                _dxAllowSetPassthrough: true\n            }, options);\n        var self = this;\n        var rootType = this._dxInfo.baseType;\n\n        if (self._listingMode === LISTINGMODE_LISTING) {\n            return;\n        }\n\n        var filter = context._filters[rootType];\n        if (!filter) {\n            if (self._dxInfo.paramDefs.dxFilterMode === dx.core.constants.LIST_TYPES.NONE) {\n                dxSet.call(self, model, options);\n                return;\n            }\n\n            filter = context._filters._uberFilter;\n        }\n\n        filter(this, model, function(placement) {\n            if (model._dxDeleted) {\n                /*\n                 * Since some filters use asynchronous requests to determine the inclusion of an object,\n                 * it is possible for an object to be deleted while a filter is executed.\n                 * We need to make sure that even if the filter determines that the object should be\n                 * included in the list, the collection discards deleted objects.\n                 */\n                return;\n            }\n            switch (placement) {\n                case context._filters.INCLUDE:\n                    dxSet.call(self, model, options);\n                    break;\n                case context._filters.EXCLUDE:\n                    self._dxRemoveModel(model, options);\n                    break;\n                case context._filters.UNKNOWN:\n                    if (self._listingMode === LISTINGMODE_IDLE) {\n                        triggerDirty(self);\n                    }\n                    break;\n                default:\n                    dx.fail('Filter returned an invalid value.');\n            }\n        });\n    }\n\n    /*\n     * Sets the autoPageRefresh property.\n     */\n    function setAutoPageRefresh(value) {\n        this._autoPageRefresh = value;\n    }\n\n    /*\n     * Return the autoPageRefresh property.\n     */\n    function getAutoPageRefresh() {\n        return this._autoPageRefresh;\n    }\n\n    /*\n     * Remove the models from this collection that are being obsoleted by the contents of the rawPropsArray. In\n     * general, we remove the models that the collection currently contains that are not part of the rawPropsArray,\n     * but if the rawPropsArray don't have a reference attribute, then we can't tell if the models are the same or not\n     * so we reset.\n     *\n     * Return whether we are resetting the collection. This is true if we're removing all elements, or if\n     * collection._resetOnList is true.\n     */\n    function removeUnneededModels(collection, rawPropsArray) {\n        var resetting = false;\n\n        if (rawPropsArray.length !== 0 && _.isUndefined(rawPropsArray[0].reference)) {\n            Backbone.Collection.prototype.remove.call(collection, collection.models, {silent: true});\n            resetting = true;\n        } else {\n            var newReferences = _.map(rawPropsArray, function(attributes) {\n                return attributes.reference;\n            });\n\n            // Figure out which models to remove (by reference). reset if removing all\n            var modelsToRemove = [];\n            collection.each(function(model) {\n                if (!_.contains(newReferences, model.id)) {\n                    modelsToRemove.push(model);\n                }\n            });\n\n            if (collection._resetOnList || modelsToRemove.length === collection.length) {\n                resetting = true;\n            }\n\n            _.each(modelsToRemove, function(model) {\n                Backbone.Collection.prototype.remove.call(collection, model, {silent: resetting});\n            });\n        }\n        return resetting;\n    }\n\n    /*\n     * Retrieve a set of models from the server, entirely replacing the contents of this collection with those models.\n     * This is a reflection of the list standard operation found in Delphix schemas.  This takes a set of query\n     * parameters as an argument, and will populate the collection with the results of that query.\n     *\n     * Note that if multiple requests are issued, this will only honor the last request sent. Models are added/removed\n     * only when the last issued request returns. This also means that ready/error events are triggered and promises\n     * resolved/rejected only once the last request issued returns.\n     *\n     * Parameters:\n     *     parameters: An object hash containing the parameters to this list operation. For example, if this is a\n     *         Container collection, you might call\n     *             myCollection.$$list({\n     *                 group: 'GROUP-1',\n     *                 parent: 'CONTAINER-23'\n     *             });\n     *     successError: A standard object that contains a success and/or error callback routine.\n     * Events:\n     *     ready:  Triggered for the collection once all the models have been added and removed. Handler argument is\n     *             the collection.\n     *             Also triggered for each model marked as ready. Handler argument is a model.\n     *     reset:  Triggered if this results in all the existing models being removed, or the _resetOnList flag has\n     *             been set to true. Argument is the collection.\n     *     remove: Triggered for each model removed, iff only some of the models are removed. Argument is the model.\n     *     add:    Triggered for each added model, iff only some of the models were removed. Argument is the model.\n     */\n    function dxList(parameters, successError) {\n        var sendableParams = context._checkAndConvertParameters(parameters, this._dxInfo.paramDefs.parameters);\n        var self = this;\n        var rootType = this._dxInfo.baseType;\n\n        // No filter function. Complain so someone writes one, and blindly add the model\n        if (dx.core.util.isNone(context._filters[rootType]) &&\n            self._dxInfo.paramDefs.dxFilterMode === dx.core.constants.LIST_TYPES.CUSTOM) {\n            dx.fail('No filter function found for collections of type ' + rootType + '. Add one to ' +\n                 ' dx.core.data._filters. In the mean time, all models will be added to the collection.');\n        }\n\n        self._dxIsReady = false;\n        self._dxIsErrored = false;\n        // Keep track of latest outstanding request. We only honor a response if it came from the latest issued request.\n        self._latestListToken++;\n        var currListToken = self._latestListToken;\n\n        self.sync('read', self, {\n            parse: true,\n            data: sendableParams,\n            success: function(resp) {\n                if (self._latestListToken !== currListToken) {\n                    return; // Another list request has been issued\n                }\n\n                if (resp && resp.type === 'ErrorResult') {\n                    var processedResult = context._newClientModel(resp.type);\n                    processedResult.set(resp);\n                    if (successError && successError.error) {\n                        successError.error(processedResult);\n                    } else {\n                        context.reportErrorResult(processedResult);\n                    }\n                    self.trigger('error', self);\n                    self._dxIsErrored = true;\n                    return;\n                }\n\n                var resetting = false;\n                self._queryParameters = dx.core.util.deepClone(parameters);\n                self._listSuccessError = successError; // save for auto-relisting\n                self._dxIsReady = true;\n                self._listingMode = LISTINGMODE_LISTING;\n\n                resp = self.parse(resp);\n\n                resetting = removeUnneededModels(self, resp) || self._resetOnList;\n\n                /*\n                 * Add the new models.\n                 */\n                _.each(resp, function(attributes) {\n                    var model = context._cache.getCachedModelFromProperties(attributes, {silent: resetting});\n                    dxSet.call(self, model, {silent: resetting, _dxAllowSetPassthrough: true});\n                });\n\n                self._listingMode = LISTINGMODE_IDLE;\n\n                // Report finishing events\n                if (resetting) {\n                    self.trigger('reset', self);\n                }\n\n                self.trigger('ready', self);\n\n                if (successError && successError.success) {\n                    successError.success();\n                }\n            },\n            error: function(xhr) {\n                if (self._latestListToken !== currListToken) {\n                    return; // Another list request has been issued\n                }\n                var errorResult = context._convertXhrToErrorResult(xhr);\n                context._handleErrorResult(errorResult, successError);\n                self.trigger('error', self);\n                self._dxIsErrored = true;\n            }\n        });\n\n        // Return a promise that is resolved once the model is ready, and rejected if the model reports an error\n        var deferred = new $.Deferred();\n        var listenerContext = {};\n\n        self.once('ready', function() {\n            deferred.resolve(self);\n            self.off(undefined, undefined, listenerContext);\n        }, listenerContext);\n\n        // don't set up the error handler if ready was already triggered\n        if (deferred.state() === 'pending') {\n            self.once('error', function() {\n                deferred.reject(self);\n                self.off(undefined, undefined, listenerContext);\n            }, listenerContext);\n        }\n\n        return deferred.promise();\n    }\n\n    /*\n     * Retrieve the last set of query parameters passed to $$list().  This is useful if you want to see what this\n     * collection currently contains.\n     */\n    function getQueryParameters() {\n        return this._queryParameters;\n    }\n\n    /*\n     * ========================================\n     * Collection creation\n     * ========================================\n     */\n\n    /*\n     * Returns a new DSB collection which is set to be a server collection.\n     *\n     * resetOnList: If true, $$list()'s will only trigger a single 'reset' event rather than individual 'add' and\n     *              'remove' events. Otherwise this happens only when the $$list() fully replaces the contents of the\n     *              collection.\n     */\n    function newServerCollection(typeName, resetOnList) {\n        if (dx.core.util.isNone(typeName)) {\n            dx.fail('To create a new collection, a type name must be provided.');\n        }\n\n        if (!isSchemaType(typeName)) {\n            dx.fail(typeName + ' is not a known type with a list operation. Can not create this collection.');\n        }\n\n        var collection = new context._collectionConstructors[typeName]();\n        collection.constructor = Backbone.Collection.extend(); // make clone() return an ordinary backbone collection.\n        collection._resetOnList = !!resetOnList;\n\n        return collection;\n    }\n\n    function operationNotAllowed() {\n        dx.fail('Can not call this operation on a Server Collection.');\n    }\n\n    /*\n     * ========================================\n     * Utility functions\n     * ========================================\n     */\n\n    function isSchemaType(typeName) {\n        return !!context._collectionConstructors[typeName];\n    }\n\n    /*\n     * Return true if the type is the same as baseType or is a subtype.\n     */\n    function isACompatibleType(type, baseType) {\n        if (!context._modelConstructors[type]) {\n            return false;\n        }\n\n        var typeDef = context._modelConstructors[type].prototype._dxSchema;\n        while (typeDef) {\n            if (typeDef.name === baseType) {\n                return true;\n            }\n            typeDef = typeDef.parentSchema;\n        }\n\n        return false;\n    }\n\n    /*\n     * Throws error if model (Backbone.Model or attributes) is not compatible with the specified type.\n     */\n    function assertModelCompatible(aModel, baseType) {\n        var type;\n        if (aModel instanceof Backbone.Model) {\n            type = aModel.get('type');\n        } else {\n            dx.fail('Can not add an arbitrary set of attributes. Must pass a Backbone Model.');\n        }\n\n        if (!isACompatibleType(type, baseType)) {\n            dx.fail('Can not add a model of type ' + type + ' to a collection with a base type of ' + baseType + '.');\n        }\n    }\n\n    /*\n     * Validates that all models are compatible with this collection's type.\n     */\n    function assertModelsCompatible(models, referenceModel) {\n        if (dx.core.util.isNone(models)) {\n            dx.fail('Can not call without a model.');\n        }\n\n        if (_.isArray(models)) {\n            _.each(models, function(model) {\n                assertModelCompatible(model, referenceModel._dxInfo.baseType);\n            }, this);\n        } else {\n            assertModelCompatible(models, referenceModel._dxInfo.baseType);\n        }\n    }\n\n    /*\n     * Trigger a 'dirty' event, and if appropriate, set up another call to do a new list operation.\n     */\n    function triggerDirty(collection) {\n        collection.trigger('dirty');\n        if (collection.getAutoPageRefresh()) {\n            setTimeout(function() {\n                dxList.call(collection, collection.getQueryParameters(), collection._listSuccessError);\n            }, 0);\n        }\n    }\n\n    /*\n     * ========================================\n     * Actually do the work of this function\n     * ========================================\n     */\n\n    context = context || this;\n    context._collectionConstructors = context._collectionConstructors || {};\n\n    _.each(schemas, function(schema, typeName) {\n        if (schema.list) {\n            // examine return values, in case the return type is not the same as the schema type\n            var retObj = schema.list.return;\n            var retItemsObj = retObj ? retObj.items : undefined;\n            var collectionType = retItemsObj  ? retItemsObj.$ref : (retObj || {}).$ref;\n            collectionType = collectionType || schema.name;\n\n            context._collectionConstructors[typeName] = Backbone.Collection.extend({\n                _dxInfo: {\n                    baseType: collectionType,\n                    paramDefs: schema.list\n                },\n                _dxIsReady: false,\n                _dxIsErrored: false,\n                _queryParameters: undefined,\n                _autoPageRefresh: false,\n                _listSuccessError: undefined,\n                _listingMode: LISTINGMODE_IDLE,\n                url: schema.root,\n                _dxEmpty: dxEmpty,\n                _dxRemoveModel: Backbone.Collection.prototype.remove,\n                _dxAddOrRemove: dxAddOrRemove,\n                model: function() {\n                    dx.fail('Can not create a new model on a collection. Must use the cache.');\n                },\n                on: dxOn,\n                add: operationNotAllowed,\n                remove: operationNotAllowed,\n                set: dxSet,\n                reset: operationNotAllowed,\n                push: operationNotAllowed,\n                pop: operationNotAllowed,\n                unshift: operationNotAllowed,\n                shift: operationNotAllowed,\n                parse: dxParse,\n                fetch: dxFetch,\n                create: dxCreate,\n                $$list: dxList,\n                _latestListToken: 0,\n                _resetOnList: false,\n                clear: dxClear,\n                getQueryParameters: getQueryParameters,\n                setAutoPageRefresh: setAutoPageRefresh,\n                getAutoPageRefresh: getAutoPageRefresh\n            });\n        }\n    });\n\n    context._newServerCollection = newServerCollection;\n};\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _ */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n\n/*\n * Creation listeners provide access to notification updates for API server objects creation in the form\n * of level2 models.\n *\n *   typeName         The schema type for which one receives notifications.\n *\n *   callback         A function to be invoked with a level2 model as argument for each create notification.\n *\n *   queryParams      Optional query parameters used to filter notifications.\n *\n *   context          The context to access other dxData content (cache, filters).\n */\nfunction CreationListener(settings) {\n    var self = this;\n    if (dx.core.util.isNone(settings.typeName)) {\n        dx.fail('To create a new creation listener, a type name must be provided.');\n    }\n    var typeName = settings.typeName;\n    var context = settings.context;\n    if (!isListableType(typeName, context)) {\n        dx.fail(typeName + ' is not a known type with a list operation. Can not create this creation listener.');\n    }\n    if (!_.isFunction(settings.callback)) {\n        dx.fail('Callback must be provided as a function.');\n    }\n\n    self._dxInfo = {\n        baseType: settings.typeName\n    };\n\n    self.inUse = true;\n\n    self.getQueryParameters = function() {\n        return settings.queryParams;\n    };\n\n    // The format must remain compatible with level2-collections and level2-cache.\n    self._dxAddOrRemove = function(model) {\n        if (!self.inUse) {\n            return;\n        }\n\n        context._filters[typeName](self, model, function(placement) {\n            switch (placement) {\n                case context._filters.INCLUDE:\n                    settings.callback(model);\n                    break;\n                case context._filters.EXCLUDE:\n                    break;\n                case context._filters.UNKNOWN:\n                    dx.fail('UNKNOWN filter result not supported by creation listeners');\n                    break;  // to keep ant check happy.\n                default:\n                    dx.fail('Filter returned an invalid value.');\n            }\n        });\n    };\n\n    self.dispose = function() {\n        self.inUse = false;\n    };\n}\n\nfunction isListableType(typeName, context) {\n    return !!context._collectionConstructors[typeName];\n}\n\n_.extend(dx.core.data, {\n    CreationListener: CreationListener\n});\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _, $, Backbone */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n/*\n * Defines general purpose filter routines. These can be used to build type-specific filters.\n *\n * A filter is simply a function that reproduces the server's treatment of the query parameters on the list operation\n * for any type.  Each filter function has the signature\n *    filterFunction(collection, model, resultHandler)\n * The filter function should examine the query parameters on the collection, then examine the properties of the model\n * and call resultHandler with a value indicating how the model should be placed with respect to the collection:\n *    INCLUDE: The model can be put in the collection\n *    EXCLUDE: The model should not be put in the collection (and removed if it is there already)\n *    UNKNOWN: The filter can't determine what to do with the model. Most likely the collection should be re-fetched\n * The potentially asynchronous call to resultHandler is necessary since some query parameters will require retrieval\n * of models to make their determination.\n */\n(function() {\n\ndx.core.data._initFilters = function(context) {\n    var EXCLUDE = 'EXCLUDE';\n    var INCLUDE = 'INCLUDE';\n    var UNKNOWN = 'UNKNOWN';\n\n    var DATE_PROPS = ['fromDate', 'startDate', 'toDate', 'endDate'];\n\n    /*\n     * Helper for non-generated filters. In many cases, the property in the query parameter is the same as that of the\n     * attribute in the model. This means we can make a decision synchronously, which keeps the logic in the filters\n     * simpler (compare to checkQueryParam(), which returns a promise).\n     * This compares the value in the query parameter with that of the model.\n     *\n     * properties: An array of property names to compare\n     * qParams:    The query parameters to compare\n     * model:      The model to compare\n     */\n    function checkSameProps(properties, qParams, model) {\n        var result = INCLUDE;\n\n        _.each(properties, function(property) {\n            if (_.has(qParams, property) && qParams[property] !== model.get(property)) {\n                result = EXCLUDE;\n            }\n        });\n\n        return result;\n    }\n\n    /*\n     * When a model is being compared against a collection that has been retrieved with paging, then we can't reliably\n     * tell whether the model belongs in the collection. Note that this assumes not specifying a page size implicitly\n     * sets it to a particular size (generally 25), while specifying 0 means 'all'\n     */\n    function checkPageSize(qParams) {\n        if (!_.has(qParams, 'pageSize') || qParams.pageSize !== 0) {\n            return UNKNOWN;\n        }\n        return INCLUDE;\n    }\n\n    /*\n     * Helper function to check date-related query parameters. This assumes qParamName is a valid date property.\n     * The caller is responsible for making sure that qParamName is one of DATE_PROPS\n     */\n    function checkDateProp(qParamVal, qParamName, qpSchema, model, attrName) {\n        if (!_.has(qpSchema, 'inequalityType')) {\n            dx.fail('Date property \"' + qParamName + '\" missing \"inequalityType\" schema property');\n        }\n        if (dx.core.util.isNone(model.get(attrName))) {\n            return EXCLUDE;\n        }\n\n        if (_.contains(['fromDate', 'startDate'], qParamName)) {\n            if (model.get(attrName).getTime() < qParamVal.getTime()) {\n                return EXCLUDE;\n            }\n        } else if (model.get(attrName).getTime() > qParamVal.getTime()) { // toDate or endDate\n            return EXCLUDE;\n        }\n\n        if (qpSchema.inequalityType === dx.core.constants.INEQUALITY_TYPES.STRICT &&\n                model.get(attrName).getTime() === qParamVal.getTime()) {\n            return EXCLUDE;\n        }\n\n        return INCLUDE;\n    }\n\n    /*\n     * Helper for the uberFilter to check an individual query parameter against the model. This may involve\n     * asynchronous ServerModel fetches to resolve 'mapsTo' data mapping chains. As a result this returns a promise to\n     * the caller. At the moment this only deals with query params that may result in INCLUDE or EXCLUDE - never\n     * UNKNOWN.\n     * The returned promise is either resolved with INCLUDE or rejected with EXCLUDE.\n     */\n    function checkQueryParam(qParamVal, qParamName, model, rootSchemaDef) {\n        var qpSchema = rootSchemaDef.list.parameters[qParamName],\n            deferred = $.Deferred(),\n            mapsTo = qpSchema.mapsTo;\n\n        if (!mapsTo) {\n            dx.fail('No mapsTo property found for query parameter ' + qParamName + '.');\n        }\n\n        var pathSegs = mapsTo.split('.');\n\n        // We know the last seg will be property to compare. Anything before will be a chain of object references.\n        var finalAttrName = pathSegs.pop();\n\n        // Recursively walk the data mapping segments\n        function followNextSeg(currModel) {\n            currModel.once('error', deferred.reject);\n            currModel.once('ready', function() {\n                if (_.isEmpty(pathSegs)) {\n                    // We've reached the end of the path. Do the actual check.\n                    var result;\n\n                    if (_.contains(DATE_PROPS, qParamName)) {\n                        result = checkDateProp(qParamVal, qParamName, qpSchema, currModel, finalAttrName);\n                    } else { // simple property check\n                        result = currModel.get(finalAttrName) === qParamVal ? INCLUDE : EXCLUDE;\n                    }\n\n                    if (result === INCLUDE) {\n                        deferred.resolve(result);\n                    } else {\n                        deferred.reject(result);\n                    }\n                } else {\n                    // recursive case - continue following path segments.\n                    var currPart = '$' + pathSegs.shift();\n                    var newModel = currModel.get(currPart);\n                    followNextSeg(newModel);\n                }\n            });\n        }\n\n        followNextSeg(model);\n\n        return deferred.promise();\n    }\n\n    function getRootedSchema(model) {\n        function upwardFind(schema, schemaName) {\n            if (dx.core.util.isNone(schema)) {\n                dx.fail('Malformed type. Root schema type not found.');\n            }\n\n            if (schema.name === schemaName) {\n                return schema;\n            }\n\n            return upwardFind(schema.parentSchema, schemaName);\n        }\n\n        if (!model._dxSchema.rootTypeName) {\n            dx.fail('Trying to filter a type that has no root type.');\n        }\n\n        return upwardFind(model._dxSchema, model._dxSchema.rootTypeName);\n    }\n\n    /*\n     * This is the filter to rule all filters. It will filter models for a given collection based on the schema\n     * definition and annotations. This may be used as a standalone filter or as a helper for another filter, usually\n     * in conjunction with the 'skipParams' argument (see alertFilter).\n     * The uberFilter can only handle 'standard' query parameters: simple equality checks, date comparisons, and\n     * paging. Similarly there are instances of query parameters that the uberFilter should not attempt to handle.\n     * These come in two flavors:\n     * 1) Params that do not affect what comes back from the notification system are marked as 'excludeFromFilter' in\n     *    the schemas.\n     * 2) Params that require special handling can be passed to the uberFilter using the 'skipParams' array.\n     */\n    function uberFilter(collection, model, resultHandler, skipParams) {\n        var qParams = collection.getQueryParameters() || {};\n        var schemaDef = getRootedSchema(model);\n        var listParams = schemaDef.list.parameters;\n\n        // If the schema definition for list says there are no parameters, then the model can always be included\n        if (_.isEmpty(schemaDef.list.parameters)) {\n            resultHandler(INCLUDE);\n        }\n\n        qParams = _.omit(qParams, skipParams);\n\n        /*\n         * If a type could have pageSize, we may need to return UNKNOWN. Otherwise we can keep going in the filter.\n         * Note that we don't care about paging params when dealing with creation listeners.\n         */\n        if (_.has(listParams, 'pageSize') && collection instanceof Backbone.Collection) {\n            var pageSizeResult = checkPageSize(qParams);\n            if (pageSizeResult === UNKNOWN) {\n                return resultHandler(pageSizeResult);\n            }\n        }\n        qParams = _.omit(qParams, ['pageSize', 'pageOffset']);\n\n        if (_.isEmpty(qParams)) {\n            return resultHandler(INCLUDE);\n        }\n        var promises = _.map(qParams, function(qParamVal, qParamName) {\n            return checkQueryParam(qParamVal, qParamName, model, schemaDef);\n        });\n\n        /*\n         * Wait until all query param checks have resolved to make a final decision. Params that might result in\n         * UNKNOWN (paging and params we can't handle) are dealt with earlier. Therefore we know each of these promises\n         * is either resolved with INCLUDE or rejected with EXCLUDE.\n         */\n        return $.when.apply(undefined, promises)\n            .then(function() {\n                resultHandler(INCLUDE);\n            })\n            .fail(function() {\n                resultHandler(EXCLUDE);\n            });\n    }\n\n    /*\n     * Simple filter for any type that doesn't actually have query parameters on its list operation (e.g. Group).\n     */\n    function genericFilter(collection, model, resultHandler) {\n        resultHandler(INCLUDE);\n    }\n\n    /*\n     * Do the real work.\n     */\n    context = context || this;\n    context._filters = context._filters || {};\n\n    _.extend(context._filters, {\n        EXCLUDE: EXCLUDE,\n        INCLUDE: INCLUDE,\n        UNKNOWN: UNKNOWN,\n        Notification: uberFilter,\n        _checkSameProps: checkSameProps,\n        _genericFilter: genericFilter,\n        _uberFilter: uberFilter\n    });\n};\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2013, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _, Backbone */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n\n/*\n * This takes a set of schemas (modified by _prepareSchemas), and creates a set of Backbone Model constructor functions\n * (and, by implication, functionality upon the models). This also creates a set of 'root operation' functions.\n * The constructor functions will be used by the level 3 API's to provide final collections to consumers of dxCore Data.\n *\n * CONSTRUCTOR FUNCTIONS\n * The models created by these constructor functions provide access to the data types that the Delphix Server works with\n * and implicitly manage the network connections to the server to get their data and perform operations on them. That\n * is, when using the models created by these constructor functions, the caller can work with the data in the server's\n * terms, and can remain insulated from managing network communication.\n *\n * Terminology notes:\n *     Attributes:       Backbone calls the name/value pairs on a Model 'attributes'.\n *     Client Model:     A model which is created on the client, and generally doesn't reflect data that exists on the\n *                       server. Most commonly, these are either parameters to operations on Server Models, or return\n *                       values from operations. Client Models are not maintained by the notification system.\n *     DSB Model:        Delphix-Schema-Based Model.  The models produced by the constructor functions this creates.\n *                       These are Backbone models that are constrained and enhanced to fit our Delphix Schema\n *                       requirements.\n *     Embedded Model:   A model that is placed 'within' another model via a object/referenceTo property in the schema.\n *     Properties:       The name/value pairs on an ordinary Javascript/JSON/JSON-Schema object are called 'properties'.\n *     Referenced Model: A model that is referenced via a string/objectReference property in another.\n *     Server Model:     A model which represents a corresponding object on the server.  These models may not be\n *                       modified from outside of the dxCore Data, since they are guaranteed to remain accurate and up\n *                       to date with the server's objects (as long as they are left inside of a collection)\n *\n * This routine (which should only be called from within the data system) consumes the schemas and creates a set of\n * Backbone Model constructor functions, one for each type in the schemas.\n *\n * The models constructed by these functions are very similar to ordinary Backbone Models, but also have a number of\n * significant differences. These differences include *incompatible* changes to the behavior of some Backbone Model\n * functions, as well as the addition of new ones.\n *\n * EVENTS\n * ready:        If you want to know if a model is ready to be used (has an initial set of data retrieved from the\n *               server), then make use of the 'ready' event, which is unique to DSB models. Ready indicates that the\n *               model has retrieved an initial set of data from the server. Unlike ordinary events, if a ready handler\n *               is assigned to a model that is already ready, that handler (and no others) will be triggered\n *               immediately. Ready handlers are  always passed the model as the first, and only, argument. The handler\n *               should have the signature (model)\n * badReference: This is triggered when a model is fetched, and a 404 is returned. The handler should have the signature\n *               (model, errorResult)\n * error:        This is reported when an error is returned from a fetch. Like ready, it will be also immediately\n *               trigger if the object is in a error state. Unlike ready, a model may go into and out of being in\n *               an error state, depending on the results of the last time it was fetched. The handler should have the\n *               signature (model, errorResult)\n * Note: The order of the triggering of badReference, error and the calling of the error handler passed to fetch are not\n * guaranteed.\n *\n * Standard Backbone properties (none of these should be changed)\n *     id              : -- : Standard\n *     idAttribute     : -- : Set to 'reference', as this is the unique ID property name for Delphix Schemas.\n *     cid             : -- : Standard\n *     attributes      : -- : Standard, but essentially private.\n *     changed         : -- : Standard, but essentially private. Use hasChanged() etc.\n *     defaults        : -- : This is not used by DSB Models\n *     validationError : -- : At this time not used.\n *     urlRoot\n *\n * Standard Backbone functions\n *     Unless otherwise noted, all functions accept only attribute names specified in the Delphix schema (they will\n *     throw an error if given something else). If an attribute is of type string/objectReference, then '$attribute' can\n *     be used to retrieve the referenced model. In the descriptions below, functions marked as S can be called on\n *     server models, while those marked as C can be called on client models.\n *\n *     get      : SC : Standard, as above.\n *     set      :  C : Standard, but accepts values for embedded models. Does not accept '$attribute' names.\n *     escape   : SC : Standard, as above. Note that Backbone's escape doesn't deal well with objects or arrays.\n *     has      : SC : Standard, as above.\n *     unset    :  C : Standard, as above. Sets attribute to default value. Embedded models clear()'ed.\n *     clear    :  C : Standard, as above. Sets attributes to default value. Embedded models clear()'ed.\n *     toJSON   : SC : Standard, as above. Recursively includes embedded models.\n *     sync     : -- : Do not use this.\n *     fetch    : -- : Do not use this. Use newClientModel() or getServerModel() instead.\n *     save     : -- : Do not use this. Use $$update() instead.\n *     destroy  : -- : Do not use this. Use $$delete() instead.\n *     keys     : SC : Standard. Does not return the '$attribute' keys.\n *     values   : SC : Standard. Returns Embedded Models, but not Referenced Models.\n *     pairs    : SC : Standard. Returns Embedded Models, but not Referenced Models.\n *     invert   : SC : Standard. Returns Embedded Models, but not Referenced Models.\n *     pick     : SC : Standard. Returns Embedded Models, but not Referenced Models.\n *     omit     : SC : Standard. Returns Embedded Models, but not Referenced Models.\n *     validate : -- : Do not use this. DSB Models do their own validation. Setting this may have bad effects.\n *     isValid  : -- : Do not use this. DSB Models always valid.\n *     url      : -- : Internal. Returns URL value used by some ajax routines\n *     parse    : -- : Internal. Processes values returned from the server.\n *     clone    : SC : Returns a Client Model which is a deep-copy of this model.\n *     isNew    : SC : Standard. (but pretty useless)\n *     hasChanged         : SC : Standard. Does not reflect $attribute names.\n *     changedAttributes  : SC : Standard. Does not reflect $attribute names.\n *     previous           : SC : Standard. Does not reflect $attribute names.\n *     previousAttributes : SC : Standard. Does not reflect $attribute names.\n *\n * DSB Model functions\n *     instanceOf    : SC : Returns whether the model is an instance of another type.\n *     isServerModel : SC : Returns true if this is a server model\n *     $$update      : S  : Updates the version of the model on the server\n *     $$delete      : S  : Deletes the server object\n *     $operation    : SC : Calls the relevant operation. Model must have a reference value to use these.\n *\n * Private to dxCore Data\n *     context._assertParametersGood    : Validate that a set of parameters are valid.\n *     context._newClientModel          : Makes a client model\n *     context._newServerModel          : Makes a server model\n *     context._getRootType             : Returns the most distant super type that has the same root property.\n *     context._convertXhrToErrorResult : Converts an xhr into an ErrorResult object.\n *\n * ROOT OPERATIONS\n * All root operations on schemas, and all create operations are stored in\n *     context.rootOps.Type.$rootOperation\n *     context.rootOps.Type.$$create\n *\n * Note: This does not alter the basic Backbone library in any way. This means this can co-exist with ordinary\n *     Backbone usage, or even other Backbone-based libraries (if they don't modify Backbone, of course).\n *\n * Parameters:\n *     schemas: The set of schemas this should generate constructors from.\n *     context: The object to put the resulting constructors (_modelConstructors) on. If not specified, puts them on\n *              'this'.\n */\ndx.core.data._generateModelConstructors = function(schemas, context) {\n\n    // Note: 'context' is the only true 'global' within this closure. Please don't add others.\n\n    /*\n     * ========================================\n     * Model functions.\n     * ========================================\n     */\n\n    /*\n     * Backbone defines this as: Bind a callback function to an object. The callback will be invoked whenever the event\n     * is fired.\n     *\n     * For DSB models, we provide standard behavior for this, but do some special processing if someone is listening\n     * for the 'ready' or 'error' event. In that case, if we have already fetched the model (or if this is a client\n     * model), then trigger the ready event immediately.  Note that if the model is already ready or in error,\n     * then we will react to 'ready' or 'error' immediately without storing the listener, since this is a one\n     * time pseudo-event.\n     */\n    function dxOn(name, callback, context) {\n        var transientTrigger;\n\n        /*\n         * If the user is asking for ready, and we are already ready or in error, then trigger the ready or\n         * do nothing. There is no reason to keep the event listener around for more than this call.\n         * Similarly if the user is asking for the error pseudo event.\n         */\n        if (name === 'ready') {\n            if (this._dxIsReady) {\n                transientTrigger = triggerReady;\n            } else if (this._dxErrorResult) {\n                return;\n            }\n        } else if (name === 'error') {\n            if (this._dxErrorResult) {\n                transientTrigger = triggerError;\n            } else if (this._dxIsReady) {\n                return;\n            }\n        }\n\n        if (transientTrigger) {\n            var tempContext = {};\n            Backbone.Events.on.call(this, name, callback, tempContext);\n            transientTrigger(this);\n            Backbone.Events.off.call(this, name, callback, tempContext);\n        } else {\n            Backbone.Events.on.call(this, name, callback, context);\n        }\n    }\n\n    /*\n     * Either 'ready' or 'error' events is triggered once in the lifecycle of a model. Cleanup listeners as soon as\n     * possible.\n     *\n     * Without this automatic cleanup, callers would have to setup 2 listeners and cancel each other when triggered.\n     * Note that we look at the list of events before triggering events so as to allow event handlers to attach new\n     * handlers.\n     */\n    function removeEventHandlers(model, events) {\n        _.each(events, function(value, name) {\n            _.each(value, function(event) {\n                if (event.callback) {\n                    model.off(name, event.callback);\n                }\n            });\n        });\n    }\n\n    /*\n     * Get a copy of the current event handlers.\n     */\n    function getEventHandlers(model) {\n        if (!model._events) {\n            return {};\n        }\n        return {\n            error: (model._events.error || []).slice(0),\n            ready: (model._events.ready || []).slice(0)\n        };\n    }\n\n    /*\n     * Trigger the 'ready' event and clean up error listeners\n     */\n    function triggerReady(model) {\n        var handlers = getEventHandlers(model);\n        model.trigger('ready', model);\n        removeEventHandlers(model, handlers);\n    }\n\n    /*\n     * Trigger the 'error' event and clean up ready listeners\n     */\n    function triggerError(model) {\n        var handlers = getEventHandlers(model);\n        model.trigger('error', model, model._dxErrorResult);\n        removeEventHandlers(model, handlers);\n    }\n\n    /*\n     * Backbone defines this as: Get the current value of an attribute from the model.\n     *\n     * For DSB models, this does the same thing, with two additional features. First, asking for an attribute that isn't\n     * in the schema definition will cause an error to be thrown.  Second, if there is an attribute named 'attr' whose\n     * schema property is of type string/objectReference, then one can also get('$attr'), and this will return the\n     * corresponding DSB model.\n     */\n    function dxGet(attrName) {\n        var info = assertAndGetAttrInfo(this, attrName);\n\n        if (isObjectRefProp(info.propDef) && info.wantsModel) {\n            var referenceValue = this.attributes[info.baseName];\n            if (dx.core.util.isNone(referenceValue)) {\n                return;\n            }\n            if (_.isString(referenceValue)) {\n                return context._cache.getCachedModel(referenceValue, getRootType(info.propDef.referenceTo));\n            }\n            dx.fail('Tried to retrieve a related object with ' + attrName + ' but value was ' + referenceValue + '.');\n        } else {\n            return Backbone.Model.prototype.get.call(this, info.baseName);\n        }\n    }\n\n    /*\n     * Backbone defines this as: Set a hash of attributes (one or many) on the model. If any of the attributes change\n     * the model's state, a 'change' event will be triggered on the model.\n     *\n     * For DSB Models, there are a number of differences.\n     *     1) Only attributes defined in the schemas can be set.\n     *     2) Attributes may only be set to values with the data type specified in the schemas.\n     *     3) DSB models may contain 'embedded' DSB models (object/$ref)\n     *\n     * To set an attribute on an embedded DSB model, one must still specify values in JSON format. Thus:\n     *     myModel.set({\n     *         attr: 1,\n     *         myEmbeddedModel: {\n     *             embeddedAttr: 34\n     *         }\n     *     })\n     * Note that it is legal, in some circumstances, to change the type of an embedded model with a set. Naturally,\n     * on a ServerModel, only the server may do this, however on a ClientModel this can happen quite freely. The\n     * important things to keep in mind are the following:\n     *     a) When the type changes, the new type must be compatible with the type declared in the schema (which is to\n     *        say you may change it to that type or any subtype, but may not change it to an unrelated type).\n     *     b) Changing a type is equivalent to setting that embedded model to a new instance. That is, any values that\n     *        were in the embedded model before the set are replaced with default values, and then the values specified\n     *        to this set() routine are applied.\n     *     c) However, listeners on this embedded model are not affected, and appropriate change notifications will be\n     *        sent on setting.\n     *\n     * A DSB model may, legitimately, have an array or object that, itself, contains a DSB model (for example, an\n     * APIError may contain a plain JSON object whose values are other APIErrors).  To deal with this properly, set()\n     * will detect any object that has a 'type' property, whose value is a Delphix-schema type name, and create a\n     * DSB model automatically. Without that type property, however, set() will treat the object as an ordinary\n     * JSON object.\n     *\n     * Arrays in a Delphix schema may or may not have a type specified for items. If they do, set() will enforce that\n     * type. If not, then the items in the array passed in will be examined and recursively processesed as appropriate.\n     * Similarly, if a plain object is encountered, set() will process its values recursively (including turning them,\n     * or their own properties, into DSB models as appropriate)\n     *\n     * A schema property defined with type=string and format=date gets some special treatment.  In that case, you can\n     * pass a string in YYYY-MM-DDTHH:MM:SS.MMMZ format, or a Javascript Date object (the former will be converted to\n     * a Date object internally, so immediately calling get() will not return the original string).\n     */\n    function dxSet(key, value, options) {\n        var self = this;\n        var newAttrs = {};\n        var preConvertAttrs;\n        var postConvertAttrs;\n\n        if (_.isUndefined(key)) {\n            return self;\n        }\n\n        if (_.isObject(key)) {\n            newAttrs = key;\n            options = value;\n\n            if (newAttrs instanceof Backbone.Model) {\n                newAttrs = newAttrs.toJSON();\n            }\n        } else {\n            newAttrs[key] = value;\n        }\n\n        options = options || {};\n\n        /*\n         * Check whether this set would change the type of the model. This only allows changing to a subtype.\n         */\n        if (newAttrs.type && newAttrs.type !== self._dxSchema.name) {\n            if (firstIsSubtypeOfSecond(newAttrs.type, self._dxSchema.name) || options._allowTypeConversion) {\n                preConvertAttrs = _.clone(self.attributes);\n                convertToType(self, newAttrs.type);\n                postConvertAttrs = _.clone(self.attributes);\n            } else {\n                dx.fail('Tried to change this from ' + self._dxSchema.name + ' to ' + newAttrs.type + '.');\n            }\n        }\n\n        /*\n         * Reject the set if any of the attributes aren't of the right type\n         */\n        var invalidAttrs = _.omit(newAttrs, _.keys(self._dxSchema.properties || {}));\n        if (!_.isEmpty(invalidAttrs)) {\n            dx.fail(_.keys(invalidAttrs) + ' are not attributes of a model of type ' + self._dxSchema.name + '.');\n        }\n\n        /*\n         * Validate types match, and prepare values to be set\n         */\n        var finalAttrs = {};\n        var subModelsToSet = {};\n        var subModelsToClear = [];\n        var subModelsToConvert = {};\n\n        _.each(newAttrs, function(newValue, newName) {\n            var propDef = self._dxSchema.properties[newName];\n            var newType = assertValueMatchesDefinition(newName, newValue, propDef);\n\n            switch (newType) {\n                case 'undefined':\n                case 'boolean':\n                case 'string':\n                case 'number':\n                case 'integer':\n                    finalAttrs[newName] = newValue;\n                    break;\n                case 'null':\n                    var nullable = _.any(propDef.type, function(type) {\n                        return type === 'null';\n                    });\n                    if (self.get(newName) instanceof Backbone.Model && !nullable) {\n                        subModelsToClear.push(newName);\n                    } else {\n                        finalAttrs[newName] = undefined;\n                    }\n                    break;\n                case 'date':\n                    if (newValue instanceof Date) {\n                        finalAttrs[newName] = new Date(newValue.getTime());\n                    } else {\n                        finalAttrs[newName] = new Date(newValue);\n                    }\n                    break;\n                case 'array':\n                    finalAttrs[newName] = setupArray(newValue, propDef.items);\n                    break;\n                case 'object':\n                    if (self.get(newName) instanceof Backbone.Model) {\n                        if (newValue.type && self.get(newName).get('type') !== newValue.type) {\n                            subModelsToConvert[newName] = newValue;\n                        } else {\n                            subModelsToSet[newName] = newValue;\n                        }\n                    } else {\n                        finalAttrs[newName] = setupObject(newValue);\n                    }\n                    break;\n            }\n        });\n\n        /*\n         * Finally, set all the values\n         */\n        _.each(subModelsToClear, function(attrName) {\n            self.get(attrName)._dxClear(options);\n        });\n\n        var revisedOptions = _.extend(_.clone(options), { _allowTypeConversion: true });\n        _.each(subModelsToConvert, function(value, key) {\n            var subModel = self.get(key);\n            subModel._dxSet(value, revisedOptions);\n        });\n\n        _.each(subModelsToSet, function(value, key) {\n            self.get(key)._dxSet(value, options);\n        });\n\n        /*\n         * If we did a type converstion, we need to make sure to send all the change:AttrName events before we send\n         * the final change event.  Because we're relying on the Backbone set routine, it may think it needs to send\n         * the change event when it is done, but we have the potential to send a variety of other events afterwards.\n         * To work around this, we store all calls to trigger() until we are done.\n         */\n        if (preConvertAttrs) {\n            interceptTrigger(self);\n        }\n\n        /*\n         * This will set all the values, and trigger change:attr events for all the attributes that changed\n         * Note that if this is doing a type conversion, this will trigger changes for:\n         *   - attributes that were added (though conversion) and then changed\n         *   - attributes that existed before and after conversion, and changed from their converted value\n         */\n        var result = Backbone.Model.prototype.set.call(self, finalAttrs, options);\n\n        if (preConvertAttrs) {\n            var removedAttrs = _.omit(preConvertAttrs, _.keys(postConvertAttrs));\n            var addedAttrs = _.omit(postConvertAttrs, _.keys(preConvertAttrs));\n            var continuedAttrs = _.pick(preConvertAttrs, _.keys(postConvertAttrs));\n\n            // trigger change events for the attributes were removed\n            _.each(removedAttrs, function(value, key) {\n                self.trigger('change:' + key, self, undefined);\n            });\n\n            // trigger change events for the attributes that were added, by conversion, but not changed\n            _.each(addedAttrs, function(value, key) {\n                if (addedAttrs[key] === self.attributes[key]) {\n                    self.trigger('change:' + key, self, self.attributes[key]);\n                }\n            });\n\n            _.each(continuedAttrs, function(value, key) {\n                /*\n                 * Suppress a change:attrName event if if the attr changed during the set() to the same value as before\n                 * the conversion suppress event/\n                 */\n                if (continuedAttrs[key] === self.attributes[key] && postConvertAttrs[key] !== self.attributes[key]) {\n                    self._suppressEvents.push('change:' + key);\n                }\n                /*\n                 * Trigger a change:attrName if the value changed during conversation, but then wasn't changed by set.\n                 * For example: The original value was 1, then when we changed the type we put the default value of 2\n                 * in, and then Backbone's set changed it to 2.  So, set() didn't send an event, but we know that\n                 * there actually was a change from the client's point of view.\n                 */\n                if (continuedAttrs[key] !== postConvertAttrs[key] && postConvertAttrs[key] === self.attributes[key]) {\n                    self.trigger('change:' + key, self, self.attributes[key]);\n                }\n            });\n\n            replayTriggers(self);\n        }\n\n        return result;\n    }\n\n    /*\n     * Intercept and queue for later restoration, all calls to trigger().\n     * This also sets up a temporary property on the model, _suppressEvents, which is a list of events to not\n     * send when replayTriggers is called.\n     */\n    function interceptTrigger(model) {\n        model._queuedEvents = [];\n        model._storedTriggerFunction = model.trigger;\n        model._suppressEvents = [];\n        model.trigger = function() {\n            model._queuedEvents.push(arguments);\n        };\n    }\n\n    /*\n     * Send all paused events on their way, with some modifications including: suppressing certain named events, and\n     * assuring a change event is sent after all change:attrName events (but not if there are none)\n     */\n    function replayTriggers(model) {\n        var changeEvent;\n        var seenAttrChange = false;\n        model.trigger = model._storedTriggerFunction;\n        delete model._storedTriggerFunction;\n\n        _.each(model._queuedEvents, function(args) {\n            // don't send the change event yet\n            if (args[0] === 'change') {\n                changeEvent = args;\n                return;\n            }\n\n            // don't send events we are to suppress\n            if (_.contains(model._suppressEvents, args[0])) {\n                return;\n            }\n\n            if (args[0].indexOf('change:') === 0) {\n                seenAttrChange = true;\n            }\n            model.trigger.apply(model, args);\n        });\n        delete model._queuedEvents;\n        delete model._suppressEvents;\n\n        if (changeEvent) {\n            model.trigger(changeEvent);\n        } else if (seenAttrChange) {\n            model.trigger('change', model);\n        }\n    }\n\n    /*\n     * Backbone defines this as: Returns true if the attribute is set to a non-null or non-undefined value.\n     */\n    function dxHas(attrName) {\n        if (!_.isString(attrName)) {\n            dx.fail('Must provide an attribute name.');\n        }\n\n        var info = getAttrInfo(this, attrName);\n\n        // dxGet will throw an exception for unknown attributes, so reach directly into the attributes to avoid this\n        return info.baseName && !dx.core.util.isNone(this.attributes[info.baseName]);\n    }\n\n    /*\n     * Backbone defines this as: Remove an attribute by deleting it from the internal attributes hash. Fires a 'change'\n     * event unless silent is passed as an option.\n     *\n     * For DSB models, the behavior is a bit different:\n     *  1) Calling unset() on a defined attribute will cause that to be reset to its default value, unless it is an\n     *     embedded object, in which case it is equivalent to calling clear() on it.\n     *  2) Calling unset() an attribute that isn't defined in the schemas will throw an error\n     *  3) calling unset('$attribute') will unset 'attribute'\n     *  4) This considers the default of a 'type' attribute to be the schema name, and so unset will never actually\n     *     change it.\n     */\n    function dxUnset(attrName, options) {\n        var info = assertAndGetAttrInfo(this, attrName);\n\n        if (attrName === 'type') {\n            return;\n        }\n\n        if (isEmbeddedProp(info.propDef)) {\n            this.attributes[attrName].clear(options);\n        } else {\n            this.set(info.baseName, defaultFor(info.propDef, this._dxIsClientModel), options);\n        }\n    }\n\n    /*\n     * Backbone defines this as: Removes all attributes from the model, including the id attribute. Fires a 'change'\n     * event unless silent is passed as an option.\n     *\n     * For DSB models, this resets all attributes to their default values, unless they are embedded objects, in which\n     * case clear() is recursively called on them.\n     */\n    function dxClear(options) {\n        var changes = {};\n        _.each(this._dxSchema.properties, function(propDef, propName) {\n            if (propName === 'type') {\n                return;\n            }\n            if (isEmbeddedProp(propDef)) {\n                this.attributes[propName]._dxClear(options);\n            } else {\n                changes[propName] = defaultFor(propDef, this._dxIsClientModel);\n            }\n        }, this);\n\n        if (!_.isEmpty(changes)) {\n            this._dxSet(changes, options);\n        }\n    }\n\n    /*\n     * Backbone defines this as: Return a copy of the model's attributes for JSON stringification. This can be used for\n     * persistence, serialization, or for augmentation before being sent to the server.\n     *\n     * Our differences are that we will recursively call this on any embedded objects, and we do deep clones of any\n     * objects or arrays.\n     */\n    function dxToJSON() {\n        return jsonIze(this);\n    }\n\n    /*\n     * Wrapper around standard Backbone url().  We do this because we build a common url access scheme that is\n     * available to both root operations and object operations.\n     */\n    function dxUrl() {\n        return this.url();\n    }\n\n    /*\n     * Backbone defines this as: parse() is called whenever a model's data is returned by the server. The function is\n     * passed the raw response object, and returns the attributes hash to be set on the model.\n     *\n     * Delphix values returned from the server come in several flavors:\n     *  1) an ErrorResult. This means that whatever request got to us failed.\n     *  2) an OKResult. This is the result of a successful call\n     *  3) a 'naked' Delphix object type. This happens when a collection is parsing each object in its returned array.\n     *  4) a ListResult, or other Delphix return value.  These should never happen here.\n     *\n     * In the case of problems (cases 1 and 4), we return undefined (we report the error result through the error result\n     * handler).  For 2 we extract the object in the result and return that. For 3, assuming the type is one we know,\n     * return that unchanged.  If it is an unknown type, however, we log an error and return undefined. An undefined\n     * return value indicates that there is no data to be parsed out of the response.\n     */\n    function dxParse(response) {\n        if (!response || !response.type) {\n            dx.warn('Got an undefined response, or one without a type in parse().');\n            return;\n        }\n\n        if (response.type === 'OKResult') {\n            return response.result;\n        } else if (isSchemaType(response.type)) {\n            return response;\n        } else {\n            dx.warn('Got an unexpected type of response (' + response.type + ') in parse().');\n            return;\n        }\n    }\n\n    /*\n     * Backbone defines this as: Returns a new instance of the model with identical attributes.\n     *\n     * For DSB models, this returns a client model that is a deep copy of the model. All embedded models are also\n     * made as client models.\n     */\n    function dxClone() {\n        var newModel = newClientModel(this._dxSchema.name);\n\n        newModel.set(this.toJSON());\n        newModel.changed = {};  // Shhh. we didn't actually change anything!\n\n        return newModel;\n    }\n\n    /*\n     * Returns true if the provided type name is this object's type name, or the type name of one of this model's\n     * extended types.  Will throw an exception if the provided type name isn't one of the schema types.\n     */\n    function instanceOf(typeName) {\n        if (!_.isString(typeName)) {\n            dx.fail('instanceOf() requires a type name as a parameter.');\n        }\n\n        if (!isSchemaType(typeName)) {\n            dx.fail(typeName + ' is not a known type name.');\n        }\n\n        var candidateTypeInfo = this._dxSchema;\n\n        while (candidateTypeInfo) {\n            if (candidateTypeInfo.name === typeName) {\n                return true;\n            }\n\n            candidateTypeInfo = candidateTypeInfo.parentSchema;\n        }\n\n        return false;\n    }\n\n    function isServerModel() {\n        return !this._dxIsClientModel;\n    }\n\n    /*\n     * Entirely block the standard Backbone destroy() routine. We want users to call $$delete() instead.\n     */\n    function noDestroy() {\n        dx.fail('Do not call destroy() directly. Instead, call $$delete().');\n    }\n\n    /*\n     * Delete this model on the server.  On success, this will clear() this model.  This will also fire\n     * a 'request' event on the model before making the call, and a 'sync' and 'destroy' afterwards on success.\n     * Depending on the underlying schema definition, this can be called in any of these ways:\n     *    $$delete([successError])  // in case of no payload defined\n     *    $$delete(payload[, successError])  // in case of payload required\n     *    $$delete([payload][, successError])  // in case of payload optional\n     */\n    function dxDelete(arg1, arg2) {\n        var opDef = this._dxSchema.delete;\n\n        if ((arg1 instanceof Backbone.Model) && !opDef.payload) {\n            dx.fail('$$delete does not allow a payload.');\n        }\n\n        var payload = arg1;\n        var successError = arg2;\n        if (!opDef.payload ||\n            !opDef.required && !(arg1 instanceof Backbone.Model)) {\n            payload = undefined;\n            successError = arg1;\n        }\n\n        assertHasReferenceAttr(this, '$delete', true);\n        var preparedData = assertAndPreparePayload('$delete', opDef, payload);\n\n        return callOperation(this, {\n            data: preparedData,\n            url: this.url()\n        }, 'DELETE', opDef, successError);\n    }\n\n    /*\n     * Create a new object on the server. It is normally called like this:\n     *    $$create(payload[, successError])\n     * However, it could be called in the following ways should a schema one day not require payload to do create\n     *    $$create([successError])  // in case of no payload defined\n     *    $$create([payload][, successError])  // in case of payload optional\n     */\n    function dxCreate(opDef, url, arg1, arg2) {\n        if ((arg1 instanceof Backbone.Model) && !opDef.payload) {\n            dx.fail('$$create does not allow a payload.');\n        }\n\n        var payload = arg1;\n        var successError = arg2;\n        if (!opDef.payload ||\n            !opDef.required && !(arg1 instanceof Backbone.Model)) {\n            payload = undefined;\n            successError = arg1;\n        }\n\n        return callOperation({}, {\n            data: assertAndPreparePayload('$create', opDef, payload),\n            url: url\n        }, 'POST', opDef, successError);\n    }\n\n    /*\n     * Entirely block the standard Backbone save() routine. We want users to call $$update() instead.\n     */\n    function noSave() {\n        dx.fail('Do not call save() directly. Instead, call $$update().');\n    }\n\n    /*\n     * Update the version of this model on the server. This sends to the server:\n     *  1) Any required or update:required attributes defined for this type\n     *  2) Any required:false or update:optional attributes from the set passed in this function\n     */\n    function dxUpdate(attributes, successError) {\n        var opDef = this._dxSchema.update;\n\n        if (dx.core.util.isNone(attributes) || _.isEmpty(attributes)) {\n            dx.fail('$$update must be called with a non-empty set of attributes.');\n        }\n        assertHasReferenceAttr(this, '$update', !this._dxSchema.singleton);\n\n        var newModel = this.clone();\n        newModel.set(attributes);\n\n        var preparedData = JSON.stringify(jsonIzeForUpdate(attributes, newModel, this, true));\n\n        return callOperation(this, {\n            data: preparedData,\n            url: this._dxGetUrl()\n        }, 'POST', opDef, successError);\n    }\n\n    /*\n     * Entirely block the standard Backbone fetc() routine.\n     */\n    function noFetch() {\n        dx.fail('Do not call fetch() directly. Instead, call getServerModel().');\n    }\n\n    /*\n     * Mark the specified model as 'ready'. The 'triggerNotify' parameter controls whether we trigger the 'ready'\n     * event. This is exposed to the level3 API so that a collection can be marked as ready before notifying consumers.\n     */\n    function makeReady(model, triggerNotify) {\n        model._dxIsReady = true;\n\n        _.each(model._dxSchema.properties, function(propDef, propName) {\n            if (isEmbeddedProp(propDef) && model.get(propName)) {\n                makeReady(model.get(propName), triggerNotify);\n            }\n        });\n\n        if (triggerNotify) {\n            triggerReady(model);\n        }\n    }\n\n    /*\n     * Handle an error for a successError callback or an array of callbacks.\n     * The context error handler is invoked once unless all callbacks define a custom error handler.\n     */\n    function handleErrorResult(processedResult, successError) {\n        var callbacks = _.isArray(successError) ? successError : [successError];\n        var reportedError = false;\n        _.each(callbacks, function(successError) {\n            if (successError && successError.error) {\n                successError.error(processedResult);\n            } else if (!reportedError && (!successError || !successError.suppressDefaultErrorHandler)) {\n                context.reportErrorResult(processedResult);\n                reportedError = true;\n            }\n        });\n    }\n\n    /*\n     * This is a slightly modified copy of the fetch function from knockback's version of Backbone. This is modified\n     * in that it calls our own private version of set and directly calls Backbone.sync (which is all that knockback's\n     * Backbone does at the moment).\n     */\n    function dxFetch(successError) {\n        var model = this;\n        model._dxFetchQueue = model._dxFetchQueue || [];\n        model._dxFetchQueue.push(successError);\n        if (model._dxFetchQueue.length === 1) {\n            dxFetchNow(model);\n        }\n    }\n\n    function dxFetchNow(model) {\n\n        /*\n         * Applies the handler to the pending request queue.\n         *\n         * If there is more than one callback in the queue, apply the response to entries 0..N-2 and issue a new\n         * dxFetch for the most recent request.\n         *\n         * If dxFetch requests are issued during callback execution, they do not resolve immediately.\n         */\n        function makeHandler(mainHandler) {\n            return function dxFetchCallbackHandler(arg) {\n                var queue = model._dxFetchQueue;\n                delete model._dxFetchQueue;\n                var callbacks = _.first(queue, Math.max(1, queue.length - 1));\n                mainHandler(arg, callbacks);\n                if (queue.length > 1) {\n                    model._dxFetch(_.last(queue));\n                }\n            };\n        }\n\n        var options = {\n            parse: true,\n            success: makeHandler(function(resp, callbacks) {\n                if (resp && resp.type === 'ErrorResult') {\n                    var processedResult = resultToModel(resp);\n                    model._dxErrorResult = processedResult;\n                    triggerError(model);\n                    return handleErrorResult(processedResult, callbacks);\n                }\n\n                model._dxErrorResult = undefined;\n                model._dxSet(model.parse(resp), options);\n\n                makeReady(model, true);\n\n                _.each(callbacks, function(successError) {\n                    if (successError && successError.success) {\n                        successError.success(model);\n                    }\n                });\n\n            }),\n            error: makeHandler(function(xhr, callbacks) {\n                var errorResult = convertXhrToErrorResult(xhr);\n                handleErrorResult(errorResult, callbacks);\n                if (xhr && xhr.status === 404) {\n                    model.trigger('badReference', model, errorResult);\n                }\n                model._dxErrorResult = errorResult;\n                triggerError(model);\n            })\n        };\n\n        Backbone.sync('read', model, options);\n    }\n\n    /*\n     * ========================================\n     * Operations: creation and handling\n     * ========================================\n     */\n\n    /*\n     * Examine the operations provided, and add them to the target object.\n     *\n     * target:     The object to add the constructed functions to\n     * operations: A JSON object with keys as the operation names, and  values as definitions of that operation.\n     * namePrefix  A string to prefix to the name of the operation when adding to the target\n     * urlPrefix:  A string to prefix to the constructed url for the operation\n     * perObject:  Whether these operations are ones that require the object's reference.\n     */\n    function addOperations(target, operations, namePrefix, urlPrefix, perObject) {\n        _.each(operations, function(opDef, opName) {\n            var opFunction;\n            var opUrl = (urlPrefix === '') ? opName : urlPrefix + '/' + opName;\n\n            if (!_.isUndefined(opDef.payload)) {\n                opFunction = (_.isEmpty(opDef.payload)) ?\n                    function(successError) {\n                        return noPayloadFunction(this, opUrl, opDef, perObject, successError);\n                    } :\n                    function(payload, successFailure) {\n                        return payloadFunction(this, opUrl, opDef, perObject, payload, successFailure);\n                    };\n            } else {\n                opFunction = (_.isEmpty(opDef.parameters)) ?\n                    function(successError) {\n                        return noParametersFunction(this, opUrl, opDef, perObject, successError);\n                    } :\n                    function(parameters, successFailure) {\n                        return parametersFunction(this, opUrl, opDef, perObject, parameters, successFailure);\n                    };\n            }\n\n            if (_.has(opDef, 'dxOperations')) {\n                addOperations(target, opDef.dxOperations, namePrefix + opName + '_', opUrl, perObject);\n            }\n\n            target['$' + namePrefix + opName] = opFunction;\n        });\n    }\n\n    /*\n     * Call a server function that has no payload.\n     */\n    function noPayloadFunction(caller, opName, opDef, perObject, successError) {\n        assertHasReferenceAttr(caller, opName, perObject);\n\n        if (successError instanceof Backbone.Model) {\n            dx.fail('$' + opName + ' can not be called with a payload (only a success/error object).');\n        }\n\n        return callOperation(caller, {\n                url: caller._dxGetUrl() + '/' + opName\n            }, 'POST', opDef, successError);\n    }\n\n    /*\n     * Call a server function that has a payload (which is always a single DSB model).\n     */\n    function payloadFunction(caller, opName, opDef, perObject, payload, successError) {\n        assertHasReferenceAttr(caller, opName, perObject);\n\n        return callOperation(caller, {\n                data: assertAndPreparePayload(opName, opDef, payload),\n                url: caller._dxGetUrl() + '/' + opName\n            }, 'POST', opDef, successError);\n    }\n\n    /*\n     * Call a server function that is a 'GET', and takes no parameters.\n     */\n    function noParametersFunction(caller, opName, opDef, perObject, successError) {\n        assertHasReferenceAttr(caller, opName, perObject);\n\n        return callOperation(caller, {\n                url: caller._dxGetUrl() + '/' + opName\n            }, 'GET', opDef, successError);\n    }\n\n    /*\n     * Call a server function that expects one or more parameters.\n     */\n    function parametersFunction(caller, opName, opDef, perObject, parameters, successError) {\n        var sendableParams;\n        assertHasReferenceAttr(caller, opName, perObject);\n\n        if (!_.isObject(parameters) && !dx.core.util.isNone(parameters)) {\n            dx.fail('$' + opName + ' must be passed a (possibly empty) hash of parameters.');\n        }\n\n        if (!dx.core.util.isNone(parameters)) {\n            sendableParams = checkAndConvertParameters(parameters, opDef.parameters);\n        }\n\n        return callOperation(caller, {\n                data: sendableParams,\n                url: caller._dxGetUrl() + '/' + opName\n            }, 'GET', opDef, successError);\n    }\n\n    function assertHasReferenceAttr(model, opName, perObject) {\n        if (!model.id && perObject) {\n            dx.fail('$' + opName + ' can not be called without a reference property set.');\n        }\n    }\n\n    /*\n     * Invoke whatever operation was set up, above, and then handle the return values.\n     * Handling a return value means:\n     *  1) If a success handler was provided, and OKResult (or subtype) was returned, pass that to the handler.\n     *  2) IF an error handler was provided, and an ErrorResult was returned, pass the ErrorResult to the handler.\n     *     Otherwise pass it on to the standard application-wide error handler, unless suppressErrorHandler was\n     *     specified.\n     *  3) IF some other error occurred, wrap the HTTP failure information into a new ErrorResult and either pass\n     *     onto the provided handler or the system-wide hander, unless suppressErrorHandler was specified.\n     */\n    function callOperation(caller, options, type, opDef, successError) {\n        if (successError && _.has(successError, 'success') && !_.isFunction(successError.success)) {\n            dx.fail('The success handler must be a function, but found a ' + typeof successError.success + '.');\n        }\n\n        if (successError && _.has(successError, 'error') && !_.isFunction(successError.error)) {\n            dx.fail('The error handler must be a function, but found a ' + typeof successError.error + '.');\n        }\n\n        var deferred = new $.Deferred();\n\n        var params = {\n            success: function(result) {\n                var processedResult;\n                if (result && result.type === 'ErrorResult') {\n                    processedResult = resultToModel(result);\n                    handleErrorResult(processedResult, successError);\n                    deferred.reject(processedResult);\n                } else {\n                    if (dx.core.util.isNone(result) || dx.core.util.isNone(result.type)) {\n                        dx.fail('Operation returned success, but without a typed object: ' + result);\n                    }\n                    if (dx.core.util.isNone(opDef.return) && result.result === '') {\n                        delete result.result;\n                    }\n                    assertValueMatchesDefinition('(return value)', result.result, opDef.return);\n                    processedResult = resultToModel(result);\n                    if (successError && successError.success) {\n                        successError.success(processedResult);\n                    }\n                    if (successError && successError.jsonSuccess) {\n                        successError.jsonSuccess(result);\n                    }\n                    if (_.isFunction(caller.trigger)) {\n                        caller.trigger('sync', caller);\n                    }\n                    deferred.resolve(processedResult);\n                }\n            },\n            error: function(xhr) {\n                var errorResult = convertXhrToErrorResult(xhr);\n                handleErrorResult(errorResult, successError);\n                deferred.reject(errorResult);\n            }\n        };\n\n        if (_.isFunction(caller.trigger)) {\n            caller.trigger('request', caller);\n        }\n\n        _.extend(params, options);\n\n        params.type = type;\n\n        dx.core.ajax.ajaxCall(params);\n        return deferred.promise();\n    }\n\n    /*\n     * Validate that the payload matches the definition for the operation.\n     */\n    function assertAndPreparePayload(opName, opDef, payload) {\n        if (dx.core.util.isNone(payload) && opDef.payload && opDef.payload.required) {\n            dx.fail('Must call $' + opName + ' with a payload of type ' + opDef.payload.$ref + '.');\n        }\n\n        if (!dx.core.util.isNone(payload)) {\n            if (!_.isObject(payload) || !(payload instanceof Backbone.Model)) {\n                dx.fail('Must call $' + opName + ' with a backbone model.');\n            }\n\n            if (!payload.instanceOf(opDef.payload.$ref)) {\n                dx.fail('Must call $' + opName + ' with an instance of ' + opDef.payload.$ref + '.');\n            }\n\n            return JSON.stringify(jsonIze(payload, opDef.validateAs || 'send'));\n        }\n    }\n\n    /*\n     * Given a parameters object (an ordinary JSON object), compare these with the parameter definitions from the\n     * schemas.  If there are any type mismatches, parameters that are not supported, or required parameters that are\n     * missing, throw an error.\n     *\n     * Return a copy of the parameters that are suitable for passing to an AJAX call (Date object converted to\n     * the server date string format)\n     */\n    function checkAndConvertParameters(parameters, paramDefinitions) {\n        parameters = parameters || {};\n        var undefinedParams = _.omit(parameters, _.keys(paramDefinitions));\n        if (!_.isEmpty(undefinedParams)) {\n            dx.fail(_.keys(undefinedParams).join(', ') + ' is not a valid parameter name.');\n        }\n\n        _.each(parameters, function(value, key) {\n            if (_.isUndefined(value)) {\n                dx.fail('Can not send a request with an undefined parameter (' + key + ' is undefined).');\n            }\n        });\n\n        _.each(paramDefinitions, function(paramDef, paramName) {\n            if (_.has(parameters, paramName)) {\n                assertValueMatchesDefinition(paramName, parameters[paramName], paramDef);\n            } else if (paramDef.required) {\n                dx.fail(paramName + ' is required, but has not been passed.');\n            }\n        });\n\n        // slightly misuse the jsonIze() routine. It does what we need, even if parameters isn't a Backbone model.\n        return jsonIze(parameters, 'send');\n    }\n\n    /*\n     * ========================================\n     * Model creation functions\n     * ========================================\n     */\n\n    /*\n     * Returns a new DSB model which is set to be a server model.\n     */\n    function newServerModel(typeName) {\n        var model = makeNewModel(typeName, false);\n\n        makeIntoServerModel(model);\n\n        return model;\n    }\n\n    /*\n     * Returns a new DSB model which is set to be a client model.\n     */\n    function newClientModel(typeName) {\n        var model = makeNewModel(typeName, true);\n        makeReady(model, true);\n        return model;\n    }\n\n    /*\n     * Convert a JSON result object into a client model.\n     */\n    function resultToModel(result) {\n        var model = newClientModel(result.type);\n        model.set(result);\n        return model;\n    }\n\n    /*\n     * Create a new model instance. Aside from creating the model, we manually populate the default set of attributes,\n     * since the Backbone system doesn't really understand embedded models.\n     */\n    function makeNewModel(typeName, isClient) {\n        if (dx.core.util.isNone(typeName)) {\n            dx.fail('To create a new model, a type name must be provided.');\n        }\n\n        if (!isSchemaType(typeName)) {\n            dx.fail(typeName + ' is not a known type name. Can not create one.');\n        } else {\n            var model = new context._modelConstructors[typeName]();\n            model._dxIsClientModel = isClient;\n            buildDefaultAttributes(model, model._dxSchema.properties || {});\n            return model;\n        }\n    }\n\n    /*\n     * Fill in the defaults for all attributes on the specified model.  This directly manipulates the attributes\n     * property, thus bypassing the normal set() semantics.  This is actually OK, as the default Backbone behavior is\n     * not to change its changedAttributes() values (etc) at creation time. Additionally, we don't want to be triggering\n     * events when doing this.\n     */\n    function buildDefaultAttributes(model, propDefs) {\n        _.each(propDefs, function(propDef, propName) {\n            model.attributes[propName] = defaultFor(propDef, model._dxIsClientModel);\n        });\n\n        if (!_.isUndefined(propDefs.type)) {\n            model.attributes.type = model._dxSchema.name;\n        }\n    }\n\n    /*\n     * Given a type definition, return the default value for that type.\n     */\n    function defaultFor(propDef, isClientModel) {\n        var defaultValue = propDef.default;\n\n        // Expose \"null\" from the server as \"undefined\" to our clients\n        if (propDef.default === null) {\n            defaultValue = undefined;\n        }\n\n        if (_.isUndefined(defaultValue) &&\n            propDef.type === 'object') {\n            defaultValue = (_.has(propDef, '$ref')) ?\n                isClientModel ? newClientModel(propDef.$ref) : newServerModel(propDef.$ref) :\n                undefined;\n        }\n\n        return defaultValue;\n    }\n\n    /*\n     * Changes the specified model (and its embedded models) into a server model.\n     */\n    function makeIntoServerModel(model) {\n        model._dxIsClientModel = false;\n\n        if (model._dxSchema.delete) {\n            model.$$delete = model._dxStandardOps.$$delete;\n        }\n\n        if (model._dxSchema.update) {\n            model.$$update = model._dxStandardOps.$$update;\n        }\n\n        model.set = cantModifyServerModel;\n        model.clear = cantModifyServerModel;\n        model.unset = cantModifyServerModel;\n        model.sync = cantModifyServerModel;\n\n        _.each(model._dxSchema.properties, function(propDef, propName) {\n            if (isEmbeddedProp(propDef)) {\n                makeIntoServerModel(model.get(propName));\n            }\n        });\n    }\n\n    function cantModifyServerModel() {\n        dx.fail('Can not modify a server ' + this._dxSchema.name + ' instance.');\n    }\n\n    /*\n     * Given a type, locate the root parent type (which will be, when walking up the inheritance chain, the last type\n     * that has the same value in its root property)\n     */\n    function getRootType(childType) {\n        if (!_.isString(childType)) {\n            dx.fail('Must call with a type name.');\n        }\n\n        if (!isSchemaType(childType)) {\n            dx.fail(childType + ' is not a known type name.');\n        }\n\n        return context._modelConstructors[childType].prototype._dxSchema.rootTypeName;\n    }\n\n    /*\n     * Given xn XmlHttpRequest (or the equivalent), either extract the ErrorResult object from within it and return\n     * that, or manufacture an ErrorResult object which contains the HTTP failure information and return that.\n     */\n    function convertXhrToErrorResult(xhr) {\n        var responseInfo = xhr.responseText;\n\n        // for testing xhr may not have getResponseHeader, and not all responses have a content-type!\n        var contentType = dx.core.util.isNone(xhr.getResponseHeader) ? undefined :\n            xhr.getResponseHeader('content-type');\n\n        if (!dx.core.util.isNone(contentType) &&\n            contentType.indexOf('application/json') > -1 &&\n            !_.isObject(responseInfo)) {\n            try {\n                responseInfo = JSON.parse(responseInfo);\n            } catch (e) {\n                dx.fail('Server response claimed to be application/json, but couldn\\'t be parsed as JSON (' +\n                    xhr.responseText + ').');\n            }\n        }\n\n        if (responseInfo && responseInfo.type === 'ErrorResult') {\n            return resultToModel(responseInfo);\n        } else {\n            var errorResult = newClientModel('ErrorResult');\n            errorResult.get('error').set({\n                details: 'Communication Error',\n                commandOutput: 'HTTP Error: ' + xhr.status + '\\n' +\n                     'Status text: ' + xhr.statusText + '\\n' +\n                     'Response text: ' + xhr.responseText\n            });\n            return errorResult;\n        }\n    }\n\n    /*\n     * ========================================\n     * 'subroutines' and utility functions\n     * ========================================\n     */\n\n    /*\n     * Validates that the attribute name is a valid attribute name for the model. If so, this returns information about\n     * the attribute (see getAttrInfo).\n     */\n    function assertAndGetAttrInfo(model, attrName) {\n        var info = getAttrInfo(model, attrName);\n\n        if (_.isUndefined(info.propDef)) {\n            dx.fail(attrName + ' is not a known attribute.');\n        }\n\n        return info;\n    }\n\n    /*\n     * This returns information about the attribute, including its base name (if the value passed was $attr, this\n     * returns 'attr'), whether this was a $-prefixed name (and thus it is actually asking for the referenced model),\n     * and the definition of the schema property.\n     */\n    function getAttrInfo(model, attrName) {\n        if (!_.isString(attrName)) {\n            dx.fail('Must provide an attribute name.');\n        }\n\n        var baseName = attrName;\n        var wantsModel = false;\n        if (baseName.charAt(0) === '$') {\n            baseName = baseName.substring(1);\n            wantsModel = true;\n        }\n        var props = model._dxSchema.properties;\n        var propDef = props ? props[baseName] : undefined;\n\n        return {\n            baseName: baseName,\n            wantsModel: wantsModel,\n            propDef: propDef\n        };\n    }\n\n    var dateStringRegex = /\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d.\\d\\d\\dZ/;\n\n    /*\n     * Asserts that the specified value matches (is compatible with) the type specified by the definition.\n     */\n    function assertValueMatchesDefinition(name, value, def) {\n        /*\n         * Returns the type of the value.  The return values include Javascript typeof type (undefined, object,\n         * boolean, number, string, etc) types, with JSON Schema type refinements (null, array, integer).\n         */\n        function typeOfValue(value) {\n            if (_.isNull(value)) {\n                return 'null';\n            }\n\n            if (_.isArray(value)) {\n                return 'array';\n            }\n\n            if (typeof value  === 'number') {\n                return (value === Math.floor(value)) ? 'integer' : 'number';\n            }\n\n            if (value instanceof Date) {\n                return 'date';\n            }\n\n            if (typeof value === 'string' && dateStringRegex.exec(value)) {\n                return 'date-or-string'; // could be either.\n            }\n\n            return typeof value;\n        }\n\n        function isTypeCompatible(actualType, objectType, defType, defObjectType, defFormat) {\n            if (actualType === 'integer' && defType === 'number') {\n                return true;\n            } else if (actualType === 'null' || actualType === 'undefined') {\n                return true;    // can assign null or undefined to all types\n            } else if (actualType === 'date' && defType === 'string' && defFormat === 'date') {\n                return true;\n            } else if (actualType === 'date-or-string' && defType === 'string') {\n                if (defFormat === 'date') {\n                    type = 'date';\n                } else {\n                    type = 'string';\n                }\n                return true;\n            } else if ((defType === 'object') && (actualType === 'object')) {\n                if (_.isUndefined(defObjectType) || // definition is typeless\n                    (!_.isUndefined(defObjectType) && _.isUndefined(objectType)) || // new value is typeless\n                    defObjectType === objectType || // types same\n                    firstIsSubtypeOfSecond(objectType, defObjectType)) { // new value is subtype\n                    return true;\n                } else {\n                    return false;\n                }\n            } else {\n                return defType === actualType;\n            }\n        }\n\n        var type = typeOfValue(value);\n        var objectType = (type === 'object') ? value.type : undefined;\n        var typeMatches;\n\n        if (_.isUndefined(def)) {\n            if (dx.core.util.isNone(value)) {\n                return type;\n            } else {\n                dx.fail(name + ' has a value, but it has no definition.');\n            }\n        }\n\n        if (_.isArray(def.type)) {\n            typeMatches = _.find(def.type, function(defType) {\n                return isTypeCompatible(type, objectType, defType, def.$ref, def.format);\n            });\n        } else {\n            typeMatches = isTypeCompatible(type, objectType, def.type, def.$ref, def.format);\n        }\n\n        if (!typeMatches) {\n            if (!def.$ref) {\n                dx.fail(name + ' has to be type ' + ((def.type === 'string' && def.format === 'date') ?\n                    'date' : def.type) + ' but is ' + type + ' (' + JSON.stringify(value) + ')');\n            } else {\n                dx.fail(name + ' has to be type ' + def.type + '/' + def.$ref + ' but is ' + type + '/' + objectType);\n            }\n        }\n\n        /*\n         * Note: def.enum throws an error in IE8.  We're also good with undefined/null from previous checks but those\n         * values obviously aren't part of the enum\n         */\n        if (def.enum && !dx.core.util.isNone(value) && !_.contains(def.enum, value)) {\n            dx.fail(name + ' is an enum and has to be one of ' + JSON.stringify(def.enum) + ' but is ' +\n                JSON.stringify(value));\n        }\n\n        return type;\n    }\n\n    /*\n     * Change the model to another type.  This is done \"in place\" since we want to preserve any listeners that may\n     * have been attached to this object.\n     *\n     * This returns true if this removed any attributes (it also triggers a 'change:attrName' event for each)\n     */\n    function convertToType(model, newType) {\n        var SourceConstructor = context._modelConstructors[model.get('type')];\n        var TargetConstructor = context._modelConstructors[newType];\n\n        // add metadata from the target type, overriding our own.\n        model._dxSchema = TargetConstructor.prototype._dxSchema;\n        model.urlRoot = TargetConstructor.prototype._dxSchema.root;\n\n        // replace our attributes\n        model.attributes = {};\n        buildDefaultAttributes(model, model._dxSchema.properties);\n\n        // Remove any operations we previously may have added to this object.\n        _.each(model, function(value, name) {\n            if (name.charAt(0) === '$') {\n                delete model[name];\n            }\n        });\n\n        /*\n         * This is really sad. Since we can't change the prototype of the object at runtime, we necessarily inherit the\n         * operations from its prototype.  But if by chance we are converting to a type that doesn't have those\n         * operations, we should not allow someone to call them. Insert a dummy function on the leaf object in the\n         * prototype chain to keep anyone from actually calling it.\n         */\n        _.each(SourceConstructor.prototype, function(value, name) {\n            if (name.charAt(0) === '$') {\n                model[name] = blockPrototypeOperation;\n            }\n        });\n\n        // Now actually add the operations to this that it should have based on the type it is being converted to.\n        _.each(TargetConstructor.prototype, function(value, name) {\n            if (name.charAt(0) === '$') {\n                model[name] = value;\n            }\n        });\n\n        if (model._dxSchema.delete) {\n            model.$$delete = dxDelete;\n        }\n\n        if (model._dxSchema.update) {\n            model.$$update = dxUpdate;\n        }\n    }\n\n    function blockPrototypeOperation() {\n        dx.fail('This operation does not exist on this instance. (it has been converted from a type that had it).');\n    }\n\n    function firstIsSubtypeOfSecond(childType, parentType) {\n        var candidateInfo = isSchemaType(childType) ?\n            context._modelConstructors[childType].prototype._dxSchema :\n            undefined;\n\n        while (candidateInfo) {\n            if (candidateInfo.name === parentType) {\n                return true;\n            }\n\n            candidateInfo = candidateInfo.parentSchema;\n        }\n\n        return false;\n    }\n\n    /*\n     * As part of the set() process, we can take a JSON array, and convert it into an array ready to be set on the\n     * model. This involves two special processes: If an 'items' property has been specified, enforce the type\n     * constraint expressed there, and if an object is found that could be converted into a DSB model, create a new\n     * model and add it.\n     */\n    function setupArray(arrayValue, itemDef) {\n        var newArray = [];\n\n        _.each(arrayValue, function(value) {\n            if (!_.isUndefined(itemDef)) {\n                assertValueMatchesDefinition('(array item)', value, itemDef);\n            }\n\n            if (_.isArray(value)) {\n                newArray.push(setupArray(value));\n            } else if (_.isObject(value)) {\n                newArray.push(setupObject(value));\n            } else {\n                newArray.push(value);\n            }\n        });\n\n        return newArray;\n    }\n\n    /*\n     * As part of the set() process, take the provided JSON object data, and either convert it into a DSB model, using\n     * the type value in the JSON object, or recursively process all the elements in the object and set those on the\n     * object this returns.\n     */\n    function setupObject(objectValue) {\n        var newObj = {};\n\n        if (objectValue instanceof Backbone.Model) {\n            objectValue = objectValue.toJSON();\n        }\n\n        if (isSchemaType(objectValue.type)) {\n            newObj = context._cache.getCachedModelFromProperties(objectValue);\n        } else {\n            _.each(objectValue, function(value, key) {\n                if (_.isArray(value)) {\n                    newObj[key] = setupArray(value);\n                } else if (_.isObject(value)) {\n                    newObj[key] = setupObject(value);\n                } else {\n                    newObj[key] = value;\n                }\n            });\n        }\n\n        return newObj;\n    }\n\n    /*\n     * Return a version of this model in JSON format, according to the specified mode. The mode may have several values\n     * which cause different versions of the model to be returned:\n     *\n     * undefined: Return all properties.\n     * send: Return all non-null required and optional values.\n     * create: Return all non-null create required and optional values, as well as required ones.\n     * update: Return all non-null update required and optional values, as well as required ones.\n     *\n     * send, create and update all throw errors if a required attribute is null or undefined (unless that attribute\n     * is of type 'null')\n     */\n    function jsonIze(value, mode) {\n        var result;\n        if (value instanceof Backbone.Model) {\n            result = {};\n            _.each(value._dxSchema.properties, function(propDef, key) {\n                var attrValue = value.get(key);\n\n                // ordinary jsonizing returns everything\n                if (_.isUndefined(mode)) {\n                    result[key] = jsonIze(attrValue, mode);\n                    return;\n                }\n\n                // Don't include read-only properties when sending a property\n                if (isReadOnly(propDef, mode)) {\n                    return;\n                }\n\n                var required = isRequired(propDef, mode);\n\n                // Don't send null when it won't be accepted\n                if (dx.core.util.isNone(attrValue) && !isNullableType(propDef)) {\n                    if (required) {\n                        dx.fail('The attribute ' + key + ' is required to be non-null/non-undefined.');\n                    }\n                    return;\n                }\n\n                result[key] = jsonIze(attrValue, mode);\n            });\n        } else if (_.isArray(value)) {\n            result = [];\n            _.each(value, function(item) {\n                result.push(jsonIze(item, mode));\n            });\n        } else if (_.isObject(value)) {\n            if (value instanceof Date) {\n                result = value.toJSON();\n            } else {\n                result = {};\n                _.each(value, function(propValue, key) {\n                    result[key] = jsonIze(propValue, mode);\n                });\n            }\n        } else {\n            result = _.isUndefined(value) ? null : value;\n        }\n\n        return result;\n    }\n\n    /*\n     * Doing a $$update requires some special handling, hence it's own jsonize routine here.  The parameters to this are\n     *    updateAttrs:   A raw object/hash of attributes that the user has asked to send as an update\n     *                   This is needed because it gives us a direct view of which attributes the caller wants to send.\n     *    updateModel:   A model that has been .set() with those attributes. This is needed because it has the forms of\n     *                   the attributes that have already been fully processed by the overall model system here.\n     *    baseModel:     The model that the update is related to. This is needed in order to retrieve some values that\n     *                   must be included in the update but were not explicitly set. It also helps us determine when a\n     *                   value doesn't need to be sent because the new value is the same as the old.\n     *    propsRequired: Whether the properties generated by this call must be included. Always true at the top level,\n     *                   and each recursive call sets it based on the schema definition.\n     *\n     * The basic algorithm here is:\n     *    Go over each property in the schema definition\n     *    If there is an update attribute for it, then add that to the hash of properties we will return\n     *      (but use the jsonIzed version of that attribute from the updateModel, to get all the benefits of proper\n     *      jsonization)\n     *    However, there are some caveats:\n     *       - If the update specifies a value which is not changed, don't send a duplicate\n     *       - If a property is required for update, but isn't included in the attributes, grab it from the\n     *         base model\n     *       - If the update attributes specified an undefined value, and the property is allowed to be null,\n     *         we send a null.\n     *       - Embedded models need special handling.  If the embedded model is required, then we simply add it to\n     *         the set of properties we are returning. If the embedded model is optional, however, then if there are no\n     *         new values in that embedded model (even if there are required properties there) then it is not included\n     *         in the update.  This, then, is the reason for the propsRequired parameter and the propCount in the\n     *         routine.  We tell each subsequent call whether we want it to return the properties even if there is\n     *         nothing new.\n     */\n    function jsonIzeForUpdate(rawUpdateObj, updateModel, baseModel, propsRequired) {\n        var jsonUpdatePayload = {};\n        var propCount = 0;\n        _.each(updateModel._dxSchema.properties, function(propDef, key) {\n            // Don't include read-only properties when sending a property\n            if (isReadOnly(propDef, 'update')) {\n                return;\n            }\n\n            var required = isRequired(propDef, 'update');\n\n            if (isEmbeddedProp(propDef)) {\n                var subProps = rawUpdateObj ? rawUpdateObj[key] : undefined;\n                var baseEmbedded = baseModel.get(key);\n                var updateEmbedded = updateModel.get(key);\n                var embJson;\n                /*\n                 * The update may legitimately be trying to change the type of an embedded object. In this case we can't\n                 * keep using the baseModel's embedded model to extract properties from (in particular, there may be\n                 * properties in the 'update' data that aren't in the embedded model, so there's nothing to extract).\n                 * Further, our definition of changing types in embedded models is that we do not preserve any\n                 * properties properties that were there before, even if they could be. In this regard, changing the\n                 * type isn't an overlay, but is instead a replace operation. To make this work here we create a new\n                 * model to be used as the base model for the recursive call to jsonIzing.\n                 */\n                if (baseEmbedded.get('type') !== updateEmbedded.get('type')) {\n                    // Doing an update that changes the type really means we are just sending the new data\n                    embJson = jsonIze(updateEmbedded, 'update');\n                } else {\n                    embJson = jsonIzeForUpdate(subProps, updateEmbedded, baseEmbedded, required);\n                }\n                if (!_.isUndefined(embJson)) {\n                    jsonUpdatePayload[key] = embJson;\n                    propCount++;\n                }\n            } else {\n                var baseAttrJson = jsonIze(baseModel.get(key), 'update');\n                var updateAttrJson = jsonIze(updateModel.get(key), 'update');\n                var updateValue = updateWithChangedValue(rawUpdateObj, key, baseAttrJson, updateAttrJson);\n\n                if (updateValue) {\n                    throwIfBadNull(updateAttrJson, propDef, key);\n                    propCount++;\n                    jsonUpdatePayload[key] = updateAttrJson;\n                }\n                if (required && !updateValue) {\n                    throwIfBadNull(baseAttrJson, propDef, key);\n                    jsonUpdatePayload[key] = baseAttrJson;\n                }\n            }\n        });\n\n        var returnValue = propsRequired || (propCount > 0);\n\n        return returnValue ? jsonUpdatePayload : undefined;\n    }\n\n    function updateWithChangedValue(rawUpdateObj, key, baseAttrJson, updateAttrJson) {\n        return (!_.isUndefined(rawUpdateObj) && _.has(rawUpdateObj, key) && !_.isEqual(baseAttrJson, updateAttrJson));\n    }\n\n    /*\n     * Determine whether the specified property is 'read only' in the current jsonizing mode. It is readonly if\n     * it there are no required or create/update settings, or if it is explicitly readonly.\n     */\n    function isReadOnly(propDef, mode) {\n        var readOnly =\n            (mode === 'create' &&\n                ((_.isUndefined(propDef.create) && _.isUndefined(propDef.required)) ||\n                    propDef.create === 'readonly')) ||\n            (mode === 'update' &&\n                ((_.isUndefined(propDef.update) && _.isUndefined(propDef.required)) ||\n                    propDef.update === 'readonly'));\n        return readOnly;\n    }\n\n    /*\n     * Determine whether the specified property is 'required' given the specified jsonizing mode.\n     */\n    function isRequired(propDef, mode) {\n        var required = (propDef.required === true) ||\n            (propDef.create === 'required' && mode === 'create') ||\n            (propDef.update === 'required' && mode === 'update');\n        return required;\n    }\n\n    /*\n     * Determine whether the specified property is one that allows null values\n     */\n    function isNullableType(propDef) {\n        return _.isArray(propDef.type) ? _.contains(propDef.type, 'null') : (propDef.type === 'null');\n    }\n\n    function isEmbeddedProp(propDef) {\n        return (propDef.type === 'object' && _.has(propDef, '$ref'));\n    }\n\n    function isObjectRefProp(propDef) {\n        if (_.isArray(propDef.type)) {\n            return _.contains(propDef.type, 'string') && propDef.format === 'objectReference';\n        }\n        return (propDef.type === 'string' && propDef.format === 'objectReference');\n    }\n\n    function throwIfBadNull(value, propDef, key) {\n        if (dx.core.util.isNone(value) && !isNullableType(propDef)) {\n            dx.fail('The attribute ' + key + ' is required to be non-null/non-undefined.');\n        }\n    }\n\n    function isSchemaType(typeName) {\n        return !!context._modelConstructors[typeName];\n    }\n\n    /*\n     * ========================================\n     * Actually do the work of this function\n     * ========================================\n     */\n\n    context = context || this;\n    context._modelConstructors = context._modelConstructors || {};\n    context.rootOps = context.rootOps || {};\n\n    _.each(schemas, function(schema, typeName) {\n        var rwModel = {\n            _dxSchema: schema,\n            _dxIsReady: false,\n            _dxErrorResult: undefined,\n            _dxIsClientModel: false,\n            _dxStandardOps: {},\n            idAttribute: 'reference',\n            urlRoot: schema.root,\n            _dxSet: dxSet,\n            _dxClear: dxClear,\n            _dxFetch: dxFetch,\n            _dxGetUrl : dxUrl,\n            _dxMakeReady: function() {\n                makeReady(this, false);\n            },\n            on: dxOn,\n            get: dxGet,\n            set: dxSet,\n            has: dxHas,\n            unset: dxUnset,\n            clear: dxClear,\n            toJSON: dxToJSON,\n            fetch: noFetch,\n            save: noSave,\n            destroy: noDestroy,\n            parse: dxParse,\n            clone: dxClone,\n            instanceOf: instanceOf,\n            isServerModel: isServerModel\n        };\n\n        function getRootUrl() {\n            return schema.root;\n        }\n\n        addOperations(rwModel, schema.operations, '', '', true);\n\n        if (schema.rootOperations) {\n            /*\n             * Root operations on singletons are, essentially object operations, as far as the client object model\n             * is concerned. So, treat those root operations as object operations.  However, there are also some\n             * singleton 'pseudo-objects' (e.g. delphix_common) which only exist to hold a few operations, so those we\n             * put on the rootOps object.  These pseudo-objects all prefixed by 'delphix_'.\n             */\n            if (schema.singleton && schema.name.indexOf('delphix_') !== 0) {\n                addOperations(rwModel, schema.rootOperations, '', '', false);\n            } else {\n                context.rootOps[typeName] = {};\n                context.rootOps[typeName]._dxGetUrl = getRootUrl;\n                addOperations(context.rootOps[typeName], schema.rootOperations, '', '', false);\n            }\n        }\n\n        if (schema.create) {\n            context.rootOps[typeName] = context.rootOps[typeName] || {};\n            context.rootOps[typeName].$$create = function(payload, successError) {\n                return dxCreate(schema.create, getRootUrl(), payload, successError);\n            };\n        }\n\n        if (schema.delete) {\n            rwModel._dxStandardOps.$$delete = dxDelete;\n        }\n\n        if (schema.update) {\n            rwModel._dxStandardOps.$$update = dxUpdate;\n        }\n\n        context._modelConstructors[typeName] = Backbone.Model.extend(rwModel);\n    });\n\n    _.extend(context, {\n        _checkAndConvertParameters: checkAndConvertParameters,\n        _newServerModel: newServerModel,\n        _newClientModel: newClientModel,\n        _getRootType: getRootType,\n        _convertXhrToErrorResult: convertXhrToErrorResult,\n        _handleErrorResult: handleErrorResult\n    });\n\n    // Add a trivial function for reporting an ErrorResult.  This is added for testing and only if level3 isn't here.\n    if (!context.reportErrorResult) {\n        context.reportErrorResult = function() {};\n    }\n};\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2013, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, $, _, Backbone */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n(function() {\n\n/*\n * This defines the public API of the Delphix Data System. It relies heavily on the infrastructure built in the\n * files containing the level 1 and level 2 code.\n *\n * This provides several public functions to get at Delphix-Schema-Based models and collections:\n *     newClientModel                  Returns a 'read/write' model of the specified schema type.\n *\n *     getServerModel                  Returns a 'read-only' model of the specified schema type which is kept in\n *                                     sync with the server as long as it remains a member of a Server Collection.\n *\n *     getServerSingleton              Returns a 'read-only' model of the specified schema type.\n *\n *     getServerCollection             Returns a 'read-only' collection which contains Server Models of a particular\n *                                     type.\n *\n *     getCreationListener             Register a creation listener for a particular type.\n *\n *     getCollectionTypeFromModelType  Returns the name of the collection type that the specified model type belongs to.\n *\n *     setErrorCallback                Set an error callback function that will be called by reportErrorResult on an\n *                                     error.\n *\n *     reportErrorResult               Convenience routine which will display an ErrorResult object to the user on the\n *                                     screen. This is mainly useful if you have an operation error handler which,\n *                                     after examining the ErrorResult model, you still wish to show it to the user.\n */\ndx.core.data.setupDataSystem = function(schemas, context) {\n    /*\n     * Returns a new client model.\n     *\n     * typeName: The type of the model. If a DB2Container is desired, then DB2Container should be passed.\n     */\n    function newClientModel(typeName) {\n        return context._newClientModel(typeName);\n    }\n\n    /*\n     * Returns a Server Collection for the specified type.  Each call returns a new collection, which may contain\n     * distinct elements from other collections of the same type.  The collection is 'read only', which means its\n     * contents may not be directly manipulated. However, its contents may be changed with the $$list() operation on\n     * the collection.\n     *\n     * typeName:    This should be the 'root type' for the collection type wanted. That is, if one wants a collection\n     *              of DB2Containers, one should pass 'Container' here.\n     * resetOnList: If true, $$list()'s will only trigger a single 'reset' event rather than individual 'add' and\n     *              'remove' events. Otherwise this happens only when the $$list() fully replaces the contents of the\n     *              collection.\n     */\n    function getServerCollection(typeName, resetOnList) {\n        var collection = context._newServerCollection(typeName, resetOnList);\n        context._modelSubscribersStore.add(collection);\n        return collection;\n    }\n\n    /*\n     * Returns a creation listener for the specified type. Each call returns a new listener, which must be disposed\n     * so as to free resources.\n     *\n     *   typeName       The schema type for which one receives notifications.\n     *\n     *   callback       A function to be invoked with a level2 model as argument for each create notification.\n     *\n     *   queryParams    Optional query parameters used to filter notifications.\n     */\n    function getCreationListener(settings) {\n        if (dx.core.util.isNone(settings)) {\n            dx.fail('Settings must be specified.');\n        }\n        _.extend(settings, {\n            context: context\n        });\n        var creationListener = new dx.core.data.CreationListener(settings);\n        context._modelSubscribersStore.add(creationListener);\n        return creationListener;\n    }\n\n    /*\n     * Returns the Server Model representing the specified singleton. If it already exists in the set of models the data\n     * system is maintaining, that same instance will be returned. Otherwise a new instance will be returned and its\n     * data asynchronously retrieved from the server.\n     *\n     * typeName:     The name of the type to fetch\n     * options:      An object that may contain success and/or error callback functions. If the model is already present\n     *               success will be invoked immediately. If it isn't present, success or error will be called once the\n     *               underlying fetch has been completed. Additionally, one may set suppressDefaultErrorHandler as an\n     *               option here to prevent the default error handler from being executed on error.\n     */\n    function getServerSingleton(typeName, options) {\n        options = _.extend(_.clone(options || {}), {\n            update: !context.notification.isStarted()\n        });\n        var model = context._cache.getCachedSingleton(typeName, options);\n\n        if (!context.notification.isStarted()) {\n            model._dxIsReady = false;   // if someone sets a ready handler, don't let it fire until new data is back\n        }\n\n        return model;\n    }\n\n    /*\n     * Return the Server Model instance with the specified reference and of the specified type. If the model already\n     * is being maintained by the data system, this will return the same instance. If not, a new instance will be\n     * returned, and a request to populate it from data on the server.  To determine if the model has at least an\n     * initial set of data, one should assign a 'ready' event handler (probably with the once() function).\n     *\n     * reference:    The reference for the model\n     * typeName:     The type for the model. If the desired model is a DB2Container, can be 'Container' or\n     *               'DB2Container'. If the type is not known, assume the most general root type ('Container') should be\n     *               passed.\n     * suppressDefaultErrorHandler:      If truthy, the default error handled is not triggered on errors.\n     */\n    function getServerModel(reference, typeName, suppressDefaultErrorHandler) {\n        var model = context._cache.getCachedModel(reference, typeName,\n            { suppressDefaultErrorHandler: suppressDefaultErrorHandler });\n\n        if (!context.notification.isStarted()) {\n            model._dxIsReady = false;   // if someone sets a ready handler, don't let it fire until new data is back\n            model._dxFetch({ suppressDefaultErrorHandler: suppressDefaultErrorHandler });\n        }\n\n        return model;\n    }\n\n    /*\n     * Gets a server model and returns a jQuery Promise.\n     * This promise is resolved with the model if/when the model's ready' event is triggered.\n     * It is rejected if/when the model's 'error' event is triggered.\n     * For a description of the parameters see context.getServerModel()\n     */\n    function getServerModelPromise(reference, typeName, suppressDefaultErrorHandler) {\n        var deferred = new $.Deferred();\n        var model = context.getServerModel(reference, typeName, suppressDefaultErrorHandler);\n\n        return setupPromise(model, deferred);\n    }\n\n    /*\n     * Gets a server singleton and returns a jQuery Promise.\n     * This promise is resolved with the singleton if/when the model's ready' event is triggered.\n     * It is rejected if/when the singleton's 'error' event is triggered.\n     * For a description of the parameters see context.getServerSingleton()\n     */\n    function getServerSingletonPromise(typeName, successError) {\n        var deferred = new $.Deferred();\n        var model = context.getServerSingleton(typeName, successError);\n\n        return setupPromise(model, deferred);\n    }\n\n    /*\n     * Helper function for getServerModelPromise and getServerSingletonPromise.\n     * Note: This is exposed as _setupPromise for testing purposes only.\n     */\n    function setupPromise(model, deferred) {\n        function onReadyCallback() {\n            deferred.resolve(model);\n        }\n        function onErrorCallback() {\n            deferred.reject(model);\n        }\n\n        model.once('ready', onReadyCallback);\n        model.once('error', onErrorCallback);\n\n        // use promise() to lock to deferred, exposing only methods to attach callbacks\n        return deferred.promise();\n    }\n\n    /*\n     * Given a model type, return the name of the 'root type'. Given DB2Container, OracleContainer, or Container, this\n     * will return Container.\n     */\n    function getCollectionTypeFromModelType(modelType) {\n        return context._getRootType(modelType);\n    }\n\n    /*\n     * Sets an error callback that will be called by reportErrorResult. This is useful for an external system to define\n     * behavior that will be used by the dxData system when an ErrorResult is reported by an operation\n     */\n    var errorCallback;\n    function setErrorCallback(func) {\n        if (!_.isFunction(func)) {\n            dx.fail('setErrorCallback expects a function as an argument.');\n        }\n        errorCallback = func;\n    }\n\n    /*\n     * Reports an ErrorResult model to the end user in the best fashion available at this time.\n     */\n    function reportErrorResult(errorResult) {\n        if (!(errorResult instanceof Backbone.Model) || errorResult.get('type') !== 'ErrorResult') {\n            dx.fail('reportErrorResult expects an ErrorResult model as an argument.');\n        }\n\n        // errorCallback is set by an external source using setErrorCallback\n        if (errorCallback) {\n            errorCallback(errorResult);\n        }\n\n        dx.warn('Error result: ' + JSON.stringify(errorResult.toJSON()));\n    }\n\n    /*\n     * Start the real work here. Initialize everything 'below' us.\n     */\n    context = context || this;\n    var parsedSchemas = dx.core.data._prepareSchemas(schemas);\n    var enums = dx.core.data._prepareEnums(parsedSchemas);\n    dx.core.data._initCache(context);\n    dx.core.data._initFilters(context);\n    dx.core.data._generateModelConstructors(parsedSchemas, context);\n    dx.core.data._generateCollectionConstructors(parsedSchemas, context);\n    dx.core.data._setupNotificationSystem(context);\n\n    _.extend(context, {\n        parsedSchemas: parsedSchemas,\n        enums: enums,\n        getServerCollection: getServerCollection,\n        getCreationListener: getCreationListener,\n        getServerSingleton: getServerSingleton,\n        newClientModel: newClientModel,\n        getServerModel: getServerModel,\n        setErrorCallback: setErrorCallback,\n        getServerModelPromise: getServerModelPromise,\n        getServerSingletonPromise: getServerSingletonPromise,\n        _setupPromise: setupPromise, // Exposed for testing purposes\n        reportErrorResult: reportErrorResult,\n        getCollectionTypeFromModelType: getCollectionTypeFromModelType\n    });\n};\n\n})();\n",
    "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright (c) 2014, 2015 by Delphix. All rights reserved.\n */\n\n/*global dx, _ */\n\n'use strict';\n\ndx.namespace('dx.core.data');\n\n/*\n * This notification system receives updates from the server about objects that have been created, deleted or updated.\n * This system, in turn, converts those notifications into calls to the underlying cache system so all models and\n * collections being used are up to date with whatever information is in the server.  Without the notification system\n * turned on, the models and collections are not assured of being up to date with what the server knows about.\n *\n * To use the notification system, simply call the start() function at the start of your program. To stop receiving\n * notifications, call stop(). You can also call isStarted() to verify whether the notification system is turned on.\n */\n(function() {\n\ndx.core.data._setupNotificationSystem = function(context) {\n\n    /*\n     * We use long polling to fetch notifications. We want to make sure our timeout is less than the browser timeout,\n     * but otherwise the call will return as soon as data is available.\n     */\n    var TIMEOUT_SEC = 12;\n\n    /*\n     * If the call fails, we don't want to spin in a loop retrying. Attempt a new request after this time period.\n     */\n    var RETRY_SEC = 10;\n\n    var date = new Date();\n    var timeout;\n    var stopped = true;\n    var notification;\n    var notificationChannel = date.getTime() + '_html';\n\n    function processNotifications(notifications) {\n        var uniqueObjectNotifications = {};\n        var uniqueSingletonNotifications = {};\n\n        /*\n         * Pre-process notifications. Keep only the last notification for a particular object. Thus, should we receive a\n         * create, update and delete notification for an object, we will only keep the delete. This assumes that we\n         * never get a non-delete notification after getting a delete notification.\n         */\n        notifications.each(function(model) {\n            switch (model.get('type')) {\n                case 'ObjectNotification':\n                    var reference = model.get('object');\n                    uniqueObjectNotifications[reference] = model;\n                    break;\n                case 'SingletonUpdate':\n                    var type = model.get('objectType');\n                    if (!_.has(uniqueSingletonNotifications, type)) {\n                        uniqueSingletonNotifications[type] = model;\n                    }\n                    break;\n                case 'NotificationDrop':\n                    dx.core.util.reloadClient(dx.gls('dx.notification_drop', model.get('dropCount')));\n                    break;\n                // we ignore all other types\n            }\n        });\n\n        /*\n         * With the uniquified set of object notifications, loop through them and retrieve or delete our copies of the\n         * objects on the server\n         */\n        _.each(uniqueObjectNotifications, function(notification, objRef) {\n            try {\n                var type = notification.get('objectType');\n                var rootType = context.getCollectionTypeFromModelType(type);\n\n                switch (notification.get('eventType')) {\n                    case 'CREATE':\n                    case 'UPDATE':\n                        var subscriptionUsesModel = context._modelSubscribersStore.hasType(rootType);\n                        var hasModel = context._cache.containsCachedModel(objRef, rootType);\n                        if (subscriptionUsesModel || hasModel) {\n                            var model = context._cache.getCachedModel(objRef, rootType, {\n                                update: true,\n                                cacheOnlyIfNeeded: true,\n                                suppressDefaultErrorHandler: true\n                            });\n                            model.once('error', function(model, err) {\n                                dx.warn('Got an error when doing a ' + notification.get('eventType') + ' on ' +\n                                    objRef + '.', err.toJSON());\n                            });\n                        }\n                        break;\n                    case 'DELETE':\n                        context._cache.deleteCachedModel(objRef, rootType);\n                        break;\n                    default:\n                        dx.warn('Unknown event type: ' + notification.get('eventType'));\n                }\n            } catch (e) {\n                // We really don't want notification processing to stop, so swallow any exception and keep going\n                dx.warn('notification processing failed: ' + e.message);\n            }\n        });\n\n        /*\n         * Finally, update all the singletons that have been changed, as well.\n         */\n        _.each(uniqueSingletonNotifications, function(notification, type) {\n            try {\n                context._cache.getCachedSingleton(type, {update: true});\n            } catch (e) {\n                // We really don't want notification processing to stop, so swallow any exception and keep going\n                dx.warn('notification processing failed: ' + e.message);\n            }\n        });\n    }\n\n    function fetchNotifications() {\n        timeout = undefined;\n\n        notification.$$list({\n            timeout: '' + TIMEOUT_SEC * 1000,\n            channel: notificationChannel\n        }, {\n            success: function() {\n                // We want to make sure notifications don't ever stall, even if there is some unknown problem\n                if (!stopped) {\n                    try {\n                        processNotifications(notification);\n                    } finally {\n                        fetchNotifications();\n                    }\n                }\n            },\n            error: function() {\n                if (!stopped) {\n                    dx.warn('Notification call failed.');\n                }\n\n                if (stopped) {\n                    return;\n                }\n\n                timeout = setTimeout(fetchNotifications, RETRY_SEC * 1000);\n            }\n        });\n    }\n\n    /*\n     * For testing purposes. This returns the timeout used for retries for predictable results.\n     */\n    function _getRetryTimeout() {\n        return RETRY_SEC * 1000;\n    }\n\n    function start() {\n        if (_.isUndefined(notification)) {\n            notification = context.getServerCollection('Notification');\n        } else {\n            dx.fail('Notification system already started.');\n        }\n        stopped = false;\n        fetchNotifications();\n    }\n\n    function isStarted() {\n        return !stopped;\n    }\n\n    function stop() {\n        if (notification) {\n            notification = undefined;\n        }\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        stopped = true;\n    }\n\n    context = context || dx.core.data;\n    context.notification = context.notification || {};\n    _.extend(context.notification, {\n        _getRetryTimeout: _getRetryTimeout,\n        start: start,\n        isStarted: isStarted,\n        stop: stop\n    });\n};\n\n})();\n"
  ]
}